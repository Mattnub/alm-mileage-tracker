<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALM Mileage Tracker v1.9.4</title>
    <style>
        /* ================================================================
           ALM MILEAGE TRACKER v1.9.4 — STYLESHEET
           ================================================================
           Sections (in order):
             1.  Reset & Base
             2.  App Layout
             3.  Sidebar & Navigation
             4.  Top Bar & Status Pills
             5.  Page Content & Headers
             6.  Route Builder Card & Forms
             7.  Stop List & Route Builder Body
             8.  Day Total Display
             9.  Map Preview
            10.  Action Buttons
            11.  Draft Banner
            12.  Toast Notifications
            13.  Page Visibility (show/hide)
            14.  Data Tables
            15.  Location Grid & Cards
            16.  Distance Matrix
            17.  Stats Grid & Stat Cards
            18.  Status Badges
            19.  Changelog
            20.  Conflict Resolution Modal
            21.  Print Styles
            22.  Print Button UI (non-print)
            23.  Distance Refresh & Spot-Check Pages
            24.  Terminal
            25.  Spot-Check Result Panel & Log
            26.  Route Picker
            27.  Animations
            28.  Responsive Breakpoints
           ================================================================ */

        /* ================================================================
           1. RESET & BASE
           ================================================================ */

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0f0f0f;
            color: #ffffff;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }

        /* ================================================================
           2. APP LAYOUT
           ================================================================ */

        .app-container {
            display: flex;
            min-height: 100vh;
        }

        .main-content {
            flex: 1;
            margin-left: 250px;
            background: #141414;
        }

        /* ================================================================
           3. SIDEBAR & NAVIGATION
           ================================================================ */

        .sidebar {
            width: 250px;
            background: #1c1c1c;
            border-right: 1px solid #2a2a2a;
            padding: 20px 0;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
        }

        .sidebar-logo {
            padding: 0 20px 30px 20px;
            border-bottom: 1px solid #2a2a2a;
            margin-bottom: 30px;
        }

        .logo-text {
            font-size: 24px;
            font-weight: 700;
            color: #ffa726;
            margin-bottom: 5px;
        }

        .logo-subtitle {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .nav-section {
            margin-bottom: 25px;
        }

        .nav-section-title {
            padding: 0 20px;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .nav-item {
            display: flex;
            align-items: center;
            padding: 12px 20px;
            color: #ccc;
            text-decoration: none;
            transition: all 0.2s;
            cursor: pointer;
            border-left: 3px solid transparent;
        }

        .nav-item:hover,
        .nav-item.active {
            background: #ffa726;
            color: #000;
            border-left-color: #ffa726;
        }

        .nav-item-icon {
            width: 16px;
            height: 16px;
            margin-right: 12px;
            font-size: 14px;
        }

        /* ================================================================
           4. TOP BAR & STATUS PILLS
           ================================================================ */

        .top-bar {
            background: #1c1c1c;
            border-bottom: 1px solid #2a2a2a;
            padding: 15px 30px;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 15px;
        }

        .status-pill {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-pill.maps-active {
            background: #22c55e;
            color: white;
        }

        .status-pill.sheets-signin {
            background: #ef4444;
            color: white;
        }

        .status-pill.total-miles {
            background: #ffa726;
            color: black;
            font-weight: 700;
        }

        /* ================================================================
           5. PAGE CONTENT & HEADERS
           ================================================================ */

        .page-content {
            padding: 30px;
        }

        .page-header {
            margin-bottom: 30px;
        }

        .page-title {
            font-size: 32px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .page-subtitle {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* ================================================================
           6. ROUTE BUILDER CARD & FORMS
           ================================================================ */

        .route-card {
            background: #1c1c1c;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            overflow: hidden;
        }

        .route-card-header {
            background: #252525;
            padding: 20px 25px;
            border-bottom: 1px solid #2a2a2a;
        }

        .section-title {
            color: #ffa726;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
        }

        .section-title::before {
            content: '';
            width: 3px;
            height: 16px;
            background: #ffa726;
            margin-right: 10px;
        }

        .route-form {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
        }

        .form-field {
            display: flex;
            flex-direction: column;
        }

        .form-field label {
            font-size: 11px;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .form-field input,
        .form-field select {
            background: #141414;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 12px 15px;
            color: #fff;
            font-size: 14px;
        }

        .form-field input:focus,
        .form-field select:focus {
            border-color: #ffa726;
            outline: none;
            box-shadow: 0 0 0 2px rgba(255, 167, 38, 0.1);
        }

        /* ================================================================
           7. STOP LIST & ROUTE BUILDER BODY
           ================================================================ */

        .route-builder {
            padding: 25px;
        }

        .stops-section {
            margin-bottom: 30px;
        }

        .stop-item {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(255, 167, 38, 0.06);
            border: 1px solid rgba(255, 167, 38, 0.2);
            border-radius: 6px;
        }

        /* Colored dot: green=start, amber=middle, red=end */
        .stop-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .stop-indicator.start  { background: #22c55e; }
        .stop-indicator.middle { background: #ffa726; }
        .stop-indicator.end    { background: #ef4444; }

        .stop-label {
            font-size: 11px;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 80px;
        }

        .stop-select {
            flex: 1;
            background: #141414;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px 12px;
            color: #fff;
            font-size: 14px;
        }

        /* Amber pill showing the leg's cached distance */
        .stop-distance {
            background: #ffa726;
            color: #000;
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 700;
            min-width: 60px;
            text-align: center;
        }

        .stop-remove {
            background: #333;
            border: none;
            color: #999;
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .stop-remove:hover {
            background: #ef4444;
            color: white;
        }

        .add-stop-btn {
            background: transparent;
            border: 1px dashed #666;
            color: #999;
            padding: 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .add-stop-btn:hover {
            border-color: #ffa726;
            color: #ffa726;
        }

        /* ================================================================
           8. DAY TOTAL DISPLAY
           ================================================================ */

        .day-total {
            background: #252525;
            border: 1px solid #2a2a2a;
            border-radius: 6px;
            padding: 20px;
            text-align: center;
            margin: 20px 0;
        }

        .total-label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .total-value {
            font-size: 36px;
            font-weight: 700;
            color: #ffa726;
        }

        .total-unit {
            font-size: 14px;
            color: #999;
            margin-left: 5px;
        }

        .total-note {
            font-size: 11px;
            color: #666;
            margin-top: 8px;
        }

        /* ================================================================
           9. MAP PREVIEW
           ================================================================ */

        .map-preview {
            background: #1c1c1c;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            margin: 20px 0;
            overflow: hidden;
        }

        .map-preview-header {
            background: #252525;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #2a2a2a;
        }

        .map-preview-title {
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #ffa726;
        }

        .map-container {
            width: 100%;
            height: 400px;
            background: #141414;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
        }

        /* ================================================================
           10. ACTION BUTTONS
           ================================================================ */

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
            margin-top: 30px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-clear         { background: #333; color: #ccc; }
        .btn-clear:hover   { background: #444; }

        .btn-preview       { background: transparent; border: 1px solid #ffa726; color: #ffa726; }
        .btn-preview:hover { background: #ffa726; color: #000; }

        .btn-save          { background: #ffa726; color: #000; }
        .btn-save:hover    { background: #ff9800; }

        .btn-secondary     { background: #333; color: #ccc; padding: 10px 16px; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; }

        .btn:disabled      { opacity: 0.4; cursor: not-allowed; }

        /* ================================================================
           11. DRAFT BANNER
           ================================================================ */

        .draft-banner {
            background: linear-gradient(135deg, #ffa726, #ff9800);
            color: #000;
            padding: 15px 25px;
            margin-bottom: 25px;
            border-radius: 6px;
            font-weight: 600;
            text-align: center;
            display: none;
        }

        .draft-banner.show { display: block; }

        .draft-actions {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .draft-btn {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(0, 0, 0, 0.3);
            color: #000;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
        }

        .draft-btn:hover { background: rgba(0, 0, 0, 0.3); }

        /* ================================================================
           12. TOAST NOTIFICATIONS
           ================================================================ */

        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            font-size: 13px;
            z-index: 1000;
            transform: translateX(400px);
            transition: transform 0.3s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .toast.show    { transform: translateX(0); }
        .toast.success { background: #22c55e; }
        .toast.error   { background: #ef4444; }
        .toast.warning { background: #ffa726; color: #000; }

        /* ================================================================
           13. PAGE VISIBILITY
           Pages are hidden by default; JS adds .active to show them.
           ================================================================ */

        .page        { display: none; }
        .page.active { display: block; }

        /* ================================================================
           14. DATA TABLES
           Used on Trip History and Cost Report pages.
           ================================================================ */

        .data-table {
            width: 100%;
            border-collapse: collapse;
            background: #141414;
            border: 1px solid #333;
            border-radius: 6px;
            overflow: hidden;
        }

        .data-table th {
            background: #252525;
            color: #ffa726;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 15px 12px;
            text-align: left;
            border-bottom: 1px solid #333;
        }

        .data-table td {
            padding: 12px;
            border-bottom: 1px solid #333;
            color: #fff;
            font-size: 13px;
        }

        .data-table tr:hover               { background: rgba(255, 167, 38, 0.05); }
        .data-table tr:last-child td       { border-bottom: none; }

        /* ================================================================
           15. LOCATION GRID & CARDS
           ================================================================ */

        .locations-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .location-card {
            background: #141414;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 20px;
            transition: all 0.2s;
        }

        .location-card:hover {
            border-color: #ffa726;
            transform: translateY(-2px);
        }

        .location-name {
            color: #ffa726;
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        /* Type badge: green=home, red=corporate, amber=dealership */
        .location-type {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
        }

        .location-type.home        { background: #22c55e; color: white; }
        .location-type.corporate   { background: #ef4444; color: white; }
        .location-type.dealership  { background: #ffa726; color: black; }

        .location-address {
            color: #ccc;
            font-size: 13px;
            line-height: 1.4;
            margin-bottom: 10px;
        }

        .location-coords {
            color: #666;
            font-size: 11px;
            font-family: monospace;
        }

        /* ================================================================
           16. DISTANCE MATRIX
           The container handles horizontal scroll with a sticky first column.
           ================================================================ */

        .distance-matrix-container {
            overflow-x: auto;
            overflow-y: visible;
            max-width: 100%;
            border: 1px solid #333;
            border-radius: 6px;
            background: #141414;
        }

        .distance-matrix {
            min-width: 900px;
            width: max-content;
            margin: 0;
        }

        .distance-matrix th,
        .distance-matrix td {
            min-width: 80px;
            text-align: center;
        }

        /* Column headers: vertical text */
        .distance-matrix th.location-header {
            background: #ffa726;
            color: black;
            font-weight: 700;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            padding: 8px 4px;
        }

        /* Row headers: horizontal text, sticky */
        .distance-matrix td.location-header {
            background: #ffa726;
            color: black;
            font-weight: 700;
            writing-mode: horizontal-tb;
            text-orientation: initial;
            padding: 8px 12px;
            text-align: left;
        }

        /* Sticky first column (row labels) */
        .distance-matrix th:first-child,
        .distance-matrix td:first-child {
            position: sticky;
            left: 0;
            background: #ffa726;
            color: black;
            font-weight: 700;
            z-index: 2;
            border-right: 2px solid #333;
        }

        .distance-matrix th:first-child { background: #444; color: white; }

        /* Cell states */
        .distance-cell             { color: #ffa726; font-weight: 600; }
        .distance-cell.unavailable { color: #666; font-style: italic; }

        /* Clickable cells jump to Spot-Check for that pair */
        .distance-cell.clickable       { cursor: pointer; transition: background 0.15s, color 0.15s; }
        .distance-cell.clickable:hover { background: rgba(245, 166, 35, 0.12); color: #f5a623; outline: 1px solid #f5a62355; }
        .distance-cell.unavailable.clickable:hover { background: rgba(255,255,255,0.05); color: #aaa; }

        /* ================================================================
           17. STATS GRID & STAT CARDS
           ================================================================ */

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .stat-card {
            background: #141414;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 20px;
            text-align: center;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: #ffa726;
            margin-bottom: 8px;
        }

        .stat-label {
            color: #666;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* ================================================================
           18. STATUS BADGES
           Used in Trip History rows: reimbursable/non-reimbursable, synced/unsynced.
           ================================================================ */

        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status-badge.reimbursable     { background: #22c55e; color: white; }
        .status-badge.non-reimbursable { background: #ef4444; color: white; }
        .status-badge.synced           { background: #22c55e; color: white; }
        .status-badge.unsynced         { background: #666;    color: white; }

        /* ================================================================
           19. CHANGELOG
           ================================================================ */

        .changelog-content {
            max-height: 600px;
            overflow-y: auto;
        }

        .changelog-version {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #333;
        }

        .changelog-version:last-child { border-bottom: none; }

        .changelog-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .version-number {
            background: #ffa726;
            color: black;
            padding: 6px 12px;
            border-radius: 4px;
            font-weight: 700;
            font-size: 14px;
        }

        .version-date { color: #666; font-size: 12px; }

        .changelog-features {
            list-style: none;
            padding: 0;
        }

        .changelog-features li {
            padding: 8px 0 8px 20px;
            color: #ccc;
            position: relative;
        }

        .changelog-features li::before {
            content: '•';
            color: #ffa726;
            font-weight: bold;
            position: absolute;
            left: 0;
        }

        /* ================================================================
           20. CONFLICT RESOLUTION MODAL
           Shown during Excel import when incoming routes overlap saved ones.
           ================================================================ */

        .modal-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.show { display: flex; }

        .conflict-modal {
            background: #1c1c1c;
            border: 1px solid #2a2a2a;
            border-radius: 12px;
            width: 90%;
            max-width: 900px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            background: #252525;
            padding: 20px 25px;
            border-bottom: 1px solid #2a2a2a;
            border-radius: 12px 12px 0 0;
        }

        .modal-title {
            color: #ffa726;
            font-size: 18px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0;
        }

        .modal-subtitle {
            color: #666;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 5px;
        }

        .modal-body    { padding: 25px; }
        .conflicts-list { margin-bottom: 20px; }

        /* Conflict item — changes color based on resolution state */
        .conflict-item {
            background: rgba(255, 167, 38, 0.06);
            border: 1px solid rgba(255, 167, 38, 0.2);
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .conflict-item.resolved-overwrite  { background: rgba(239, 68, 68, 0.06);  border-color: rgba(239, 68, 68, 0.2); }
        .conflict-item.resolved-skip       { background: rgba(102, 102, 102, 0.06); border-color: rgba(102, 102, 102, 0.2); opacity: 0.7; }
        .conflict-item.resolved-keep-both  { background: rgba(34, 197, 94, 0.06);  border-color: rgba(34, 197, 94, 0.2); }

        .conflict-header {
            background: rgba(255, 167, 38, 0.1);
            padding: 15px 20px;
            border-bottom: 1px solid rgba(255, 167, 38, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .conflict-date      { font-size: 16px; font-weight: 700; color: #ffa726; }
        .conflict-indicator { background: #ef4444; color: white; padding: 4px 12px; border-radius: 12px; font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; }

        .conflict-comparison {
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
        }

        .conflict-side {
            background: #141414;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
        }

        .conflict-side h4 {
            color: #ffa726;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        .conflict-detail {
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
        }

        .conflict-label { color: #999; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; }
        .conflict-value { color: #fff; font-weight: 600; }

        .conflict-actions {
            padding: 15px 20px;
            background: #252525;
            border-top: 1px solid #2a2a2a;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .date-adjustment {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-right: auto;
        }

        .date-adjustment label {
            color: #999;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .date-adjustment input {
            background: #141414;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 8px 12px;
            color: #fff;
            font-size: 14px;
            width: 140px;
        }

        .conflict-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .conflict-btn.overwrite        { background: #ef4444; color: white; }
        .conflict-btn.overwrite:hover  { background: #dc2626; }
        .conflict-btn.skip             { background: #666; color: white; }
        .conflict-btn.skip:hover       { background: #777; }
        .conflict-btn.keep-both        { background: #22c55e; color: white; }
        .conflict-btn.keep-both:hover  { background: #16a34a; }

        .modal-footer {
            background: #252525;
            padding: 20px 25px;
            border-top: 1px solid #2a2a2a;
            border-radius: 0 0 12px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bulk-actions     { display: flex; gap: 10px; }
        .conflicts-summary { color: #666; font-size: 13px; }

        /* ================================================================
           21. PRINT STYLES
           Hides chrome, forces white background, adds report header/footer.
           ================================================================ */

        @media print {

            /* Hide all navigation, buttons, and interactive chrome */
            .sidebar,
            .top-bar,
            .modal-overlay,
            .toast,
            .draft-banner,
            .btn,
            button,
            .action-buttons,
            .conflict-actions,
            .nav-item,
            .map-preview,
            .map-container,
            .print-section {
                display: none !important;
            }

            /* Full-width content, no side margin */
            .main-content {
                margin-left: 0 !important;
                width: 100% !important;
            }

            .page-content {
                padding: 0 !important;
                margin: 0 !important;
            }

            /* Avoid splitting a route card across pages */
            .route-card     { page-break-inside: avoid; margin-bottom: 20px; }
            .page-header    { page-break-after: avoid;  margin-bottom: 20px; }

            /* White background, black text throughout */
            body                            { background: white !important; color: black !important; }
            .route-card,
            .route-card-header              { background: white !important; border: 1px solid #000 !important; color: black !important; }
            .data-table                     { background: white !important; border-collapse: collapse !important; }
            .data-table th                  { background: #f0f0f0 !important; color: black !important; border: 1px solid #000 !important; }
            .data-table td                  { color: black !important; border: 1px solid #000 !important; }
            .page-title                     { color: black !important; font-size: 24px !important; }
            .page-subtitle                  { color: #666 !important; }
            .section-title                  { color: black !important; }
            .section-title::before          { background: black !important; }
            .status-badge                   { border: 1px solid #000 !important; background: white !important; color: black !important; }
            .stat-value,
            .total-value,
            .conflict-value                 { color: black !important; }

            /* Page setup */
            @page { size: A4; margin: 0.75in; }

            /* Report branding injected via CSS pseudo-elements */
            .page-header::before {
                content: "ALM Mileage Tracker — Printed Report";
                display: block;
                font-size: 12px;
                color: #666;
                margin-bottom: 10px;
                text-align: right;
            }

            .page-header::after {
                content: "Generated: " attr(data-print-date);
                display: block;
                font-size: 10px;
                color: #666;
                text-align: right;
                margin-top: 5px;
            }
        }

        /* ================================================================
           22. PRINT BUTTON UI  (visible on screen only, hidden on print)
           Panel shown inside Trip History and Cost Report to trigger printing.
           ================================================================ */

        .print-section {
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 167, 38, 0.1);
            border: 1px solid rgba(255, 167, 38, 0.3);
            border-radius: 6px;
            text-align: center;
        }

        .print-btn {
            background: #ffa726;
            color: black;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            margin: 0 5px;
        }

        .print-btn:hover { background: #ff9800; }

        /* ================================================================
           23. DISTANCE REFRESH & SPOT-CHECK PAGES
           Status bar, action button group, and shared layout.
           ================================================================ */

        .sync-status-bar {
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 18px 25px;
            background: #1c1c1c;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .sync-status-item  { display: flex; flex-direction: column; gap: 4px; }

        .sync-status-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .sync-status-value               { font-size: 14px; font-weight: 600; color: #fff; }
        .sync-status-value.good          { color: #22c55e; }
        .sync-status-value.warn          { color: #ffa726; }
        .sync-status-value.bad           { color: #ef4444; }

        .sync-divider { width: 1px; height: 36px; background: #2a2a2a; }

        .refresh-btn-group {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        /* Primary refresh button */
        .btn-refresh-all {
            background: #ffa726;
            color: #000;
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-refresh-all:hover    { background: #ff9800; }
        .btn-refresh-all:disabled { opacity: 0.4; cursor: not-allowed; }

        /* Secondary: refresh used routes only */
        .btn-refresh-used {
            background: transparent;
            color: #ffa726;
            border: 1px solid #ffa726;
            padding: 12px 24px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-refresh-used:hover    { background: rgba(255,167,38,0.1); }
        .btn-refresh-used:disabled { opacity: 0.4; cursor: not-allowed; }

        /* Destructive: clear cache */
        .btn-clear-cache {
            background: transparent;
            color: #ef4444;
            border: 1px solid #ef4444;
            padding: 12px 24px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-clear-cache:hover { background: rgba(239,68,68,0.1); }

        /* ================================================================
           24. TERMINAL
           macOS-style terminal shell used on the Distance Refresh page.
           ================================================================ */

        .terminal-wrap {
            background: #0a0a0a;
            border: 1px solid #1e3a1e;
            border-radius: 8px;
            overflow: hidden;
        }

        .terminal-header {
            background: #111;
            padding: 10px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 1px solid #1e3a1e;
        }

        /* Traffic-light dots */
        .terminal-dot           { width: 10px; height: 10px; border-radius: 50%; }
        .terminal-dot.red       { background: #ef4444; }
        .terminal-dot.yellow    { background: #ffa726; }
        .terminal-dot.green     { background: #22c55e; }

        .terminal-title {
            font-size: 11px;
            color: #666;
            margin-left: 6px;
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
        }

        .terminal-body {
            padding: 16px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 13px;
            line-height: 1.7;
            min-height: 300px;
            max-height: 500px;
            overflow-y: auto;
            color: #22c55e;
        }

        /* Terminal text color classes */
        .terminal-body .t-dim   { color: #444; }
        .terminal-body .t-info  { color: #22c55e; }
        .terminal-body .t-warn  { color: #ffa726; }
        .terminal-body .t-error { color: #ef4444; }
        .terminal-body .t-ok    { color: #22c55e; font-weight: bold; }
        .terminal-body .t-ts    { color: #555; }
        .terminal-body .t-hi    { color: #fff; font-weight: bold; }

        /* Blinking block cursor */
        .terminal-body .t-cursor {
            display: inline-block;
            width: 8px;
            height: 14px;
            background: #22c55e;
            vertical-align: text-bottom;
            animation: blink 1s step-end infinite;
        }

        /* ================================================================
           25. SPOT-CHECK RESULT PANEL & LOG
           ================================================================ */

        .spotcheck-form {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 20px;
            align-items: end;
            margin-bottom: 20px;
        }

        /* Hidden until a check runs */
        .spotcheck-result {
            background: #0f1f0f;
            border: 1px solid #1e3a1e;
            border-radius: 8px;
            padding: 20px 25px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            display: none;
        }

        .spotcheck-result.show { display: block; }

        .spotcheck-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #1a2a1a;
            color: #ccc;
        }

        .spotcheck-row:last-child { border-bottom: none; }

        .spotcheck-key         { color: #666; }
        .spotcheck-val         { font-weight: bold; color: #22c55e; }
        .spotcheck-val.mismatch { color: #ef4444; }
        .spotcheck-val.match    { color: #22c55e; }
        .spotcheck-val.pending  { color: #ffa726; }

        /* MATCH / MISMATCH / NO CACHE / SAVED badge */
        .match-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .match-badge.match    { background: rgba(34,197,94,0.2);  color: #22c55e; border: 1px solid #22c55e; }
        .match-badge.mismatch { background: rgba(239,68,68,0.2);  color: #ef4444; border: 1px solid #ef4444; }
        .match-badge.no-cache { background: rgba(255,167,38,0.2); color: #ffa726; border: 1px solid #ffa726; }

        .spotcheck-log-entry {
            padding: 6px 0;
            border-bottom: 1px solid #1a2a1a;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #666;
        }

        .spotcheck-log-entry .log-time  { color: #444; }
        .spotcheck-log-entry .log-match { color: #22c55e; }
        .spotcheck-log-entry .log-miss  { color: #ef4444; }

        /* ================================================================
           26. ROUTE PICKER
           Inline card that appears when a leg has no cached distance.
           User picks a route; the choice is written to cache immediately.
           ================================================================ */

        .route-picker {
            margin: 0 0 12px 0;
            padding: 14px 16px;
            background: #0f1a0f;
            border: 1px solid #1e3a1e;
            border-radius: 6px;
            animation: fadeIn 0.2s ease;
        }

        .route-picker-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
        }

        .route-picker-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .route-option-btn {
            background: #1a2a1a;
            border: 1px solid #2a4a2a;
            color: #ccc;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            font-family: 'Segoe UI', system-ui, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            min-width: 90px;
        }

        .route-option-btn:hover    { background: #ffa726; border-color: #ffa726; color: #000; }
        .route-option-btn.selected { background: #22c55e; border-color: #22c55e; color: #000; }

        .route-option-miles {
            font-size: 16px;
            font-weight: 700;
        }

        .route-option-sub {
            font-size: 10px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Used when only a single route is available */
        .route-picker-single {
            color: #ffa726;
            font-size: 12px;
            font-family: 'Courier New', monospace;
        }

        .route-picker-loading {
            color: #555;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* ================================================================
           27. ANIMATIONS
           ================================================================ */

        /* Blinking cursor used in the terminal */
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50%       { opacity: 0; }
        }

        /* Slide-in for route picker cards */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-4px); }
            to   { opacity: 1; transform: translateY(0); }
        }

        /* ================================================================
           28. RESPONSIVE BREAKPOINTS
           All @media queries consolidated here.
           ================================================================ */

        @media (max-width: 768px) {

            /* Sidebar slides off-canvas on small screens */
            .sidebar {
                transform: translateX(-100%);
                transition: transform 0.3s;
            }

            .main-content { margin-left: 0; }

            /* Single-column forms */
            .route-form    { grid-template-columns: 1fr; }

            /* Stack action buttons vertically */
            .action-buttons { flex-direction: column; }

            /* Single-column grids */
            .locations-grid { grid-template-columns: 1fr; }
            .stats-grid     { grid-template-columns: 1fr; }

            /* 4-col filter row collapses to 2 */
            .route-form[style*="grid-template-columns: repeat(4, 1fr)"] {
                grid-template-columns: repeat(2, 1fr);
            }

            /* Hint text when matrix needs horizontal scroll */
            .distance-matrix-container { position: relative; }
            .distance-matrix-container::after {
                content: 'Scroll horizontally to view all columns →';
                position: absolute;
                bottom: -25px;
                right: 0;
                color: #666;
                font-size: 11px;
                font-style: italic;
            }

            /* Conflict modal: stack comparison panels */
            .conflict-comparison  { grid-template-columns: 1fr; }
            .conflict-actions     { flex-direction: column; align-items: stretch; gap: 10px; }
            .date-adjustment      { margin-right: 0; justify-content: center; }
        }
    </style>
</head>
<body>
    <!--
    ╔══════════════════════════════════════════════════════════════════╗
    ║  ALM MILEAGE TRACKER v1.9.4 — HTML STRUCTURE OVERVIEW           ║
    ║                                                                  ║
    ║  <body>                                                          ║
    ║    <div.app-container>          flex root                        ║
    ║      <aside.sidebar>            fixed left nav (250px)           ║
    ║      <main.main-content>        scrollable right panel           ║
    ║        <div.top-bar>            status pills                     ║
    ║        <div.draft-banner>       resume/discard draft             ║
    ║        <div.page-content>       9 page divs (only 1 active)      ║
    ║          #log-page              New Route builder                ║
    ║          #history-page          Trip History + filters           ║
    ║          #locations-page        Location directory               ║
    ║          #matrix-page           Distance Matrix grid             ║
    ║          #charts-page           Charts + stats                   ║
    ║          #cost-page             Cost Report                      ║
    ║          #dist-refresh-page     Bulk cache refresh               ║
    ║          #dist-spotcheck-page   Single-pair spot check           ║
    ║          #changelog-page        Version history                  ║
    ║    <div.modal-overlay>          Import conflict modal (fixed)    ║
    ║    External scripts             Maps API, Chart.js, SheetJS      ║
    ╚══════════════════════════════════════════════════════════════════╝
    -->
    <div class="app-container">
        <!-- ═══════════════════════════════════════════════════════════
             SIDEBAR NAVIGATION
             Fixed 250px left panel. Nav items use data-page="<id>" to
             tell setupNavigation() which page div to activate on click.
             Export items use onclick directly (no page switch needed).
        ════════════════════════════════════════════════════════════════ -->
        <aside class="sidebar">
            <div class="sidebar-logo">
                <div class="logo-text">ALM</div>
                <div class="logo-subtitle">MILEAGE TRACKER v1.9.4</div>
            </div>
            
            <div class="nav-section">
                <div class="nav-section-title">LOG</div>
                <a href="#" class="nav-item active" data-page="log">
                    <span class="nav-item-icon">+</span>
                    New Route
                </a>
                <a href="#" class="nav-item" data-page="history">
                    <span class="nav-item-icon">⏱</span>
                    Trip History
                </a>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">DATA</div>
                <a href="#" class="nav-item" data-page="locations">
                    <span class="nav-item-icon">📍</span>
                    Locations
                </a>
                <a href="#" class="nav-item" data-page="matrix">
                    <span class="nav-item-icon">⊞</span>
                    Distance Matrix
                </a>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">ANALYSIS</div>
                <a href="#" class="nav-item" data-page="charts">
                    <span class="nav-item-icon">📊</span>
                    Charts
                </a>
                <a href="#" class="nav-item" data-page="cost">
                    <span class="nav-item-icon">$</span>
                    Cost Report
                </a>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">EXPORT</div>
                <a href="#" class="nav-item" onclick="downloadExcel()">
                    <span class="nav-item-icon">↓</span>
                    Download Excel
                </a>
                <a href="#" class="nav-item" onclick="importExcel()">
                    <span class="nav-item-icon">↑</span>
                    Import Excel
                </a>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">APP</div>
                <a href="#" class="nav-item" data-page="dist-refresh">
                    <span class="nav-item-icon">⟲</span>
                    Distance Refresh
                </a>
                <a href="#" class="nav-item" data-page="dist-spotcheck">
                    <span class="nav-item-icon">🔍</span>
                    Distance Spot-Check
                </a>
                <a href="#" class="nav-item" data-page="changelog">
                    <span class="nav-item-icon">📋</span>
                    Changelog
                </a>
            </div>
        </aside>

        <!-- ═══════════════════════════════════════════════════════════
             MAIN CONTENT AREA
             Fills viewport minus the 250px sidebar. Contains the top bar,
             the draft resume banner, and the page-content div that holds
             all 9 page divs. JS shows/hides pages by toggling .active.
        ════════════════════════════════════════════════════════════════ -->
        <main class="main-content">
            <!-- Top Bar: Maps status pill, Sheets status pill, running
                 total miles pill. Updated by updateStatus() on init and
                 after every save. -->
            <div class="top-bar">
                <div class="status-pill maps-active" id="maps-status">
                    ● MAPS ACTIVE
                </div>
                <div class="status-pill sheets-signin" id="sheets-status">
                    ● SHEETS: SIGN IN
                </div>
                <div class="status-pill total-miles">
                    <span id="total-miles-display">0.0</span> MI TOTAL
                </div>
            </div>

            <!-- Draft Banner: hidden by default (.draft-banner { display:none }).
                 checkDraft() shows it on load if localStorage has a saved draft.
                 resumeDraft() restores the form; discardDraft() clears it. -->
            <div class="draft-banner" id="draft-banner">
                DRAFT FOUND - You have an unsaved route in progress
                <div class="draft-actions">
                    <button class="draft-btn" onclick="resumeDraft()">Resume Draft</button>
                    <button class="draft-btn" onclick="discardDraft()">Discard Draft</button>
                </div>
            </div>

            <!-- ═══════════════════════════════════════════════════════
                 PAGE CONTENT CONTAINER
                 All 9 pages live here as siblings. Only the one with
                 class="page active" is visible. setupNavigation() swaps
                 the .active class on every nav-item click, then calls
                 initializePage() to load data for the new page.
            ════════════════════════════════════════════════════════════ -->
            <div class="page-content">
                <!-- ═══════════════════════════════════════════════════
                     PAGE: LOG  (#log-page)
                     The main route builder. Active by default on load.
                     Contains:
                       • Route Details header (date + purpose form)
                       • Route Builder body (dynamic stop list)
                       • Day Total display (hidden until legs are resolved)
                       • Map Preview (hidden until Preview Route is clicked)
                       • Action Buttons (Clear / Preview Route / Save Route)
                     Stop rows are injected dynamically by addStopAtIndex().
                     Route pickers appear inline when a leg has no cache hit.
                ════════════════════════════════════════════════════════ -->
                <div class="page active" id="log-page">
                    <div class="page-header">
                        <h1 class="page-title">New Route</h1>
                        <p class="page-subtitle">BUILD YOUR DAY'S STOPS - UP TO 6 LOCATIONS</p>
                    </div>

                    <!-- Route Card -->
                    <div class="route-card">
                        <!-- Route Details Header -->
                        <div class="route-card-header">
                            <div class="section-title">Route Details</div>
                            <form class="route-form">
                                <div class="form-field">
                                    <label>Date</label>
                                    <input type="date" id="trip-date">
                                </div>
                                <div class="form-field">
                                    <label>Purpose</label>
                                    <select id="trip-purpose">
                                        <option value="">Dealership Visits</option>
                                        <option value="Sales Visit">Sales Visit</option>
                                        <option value="Service Call">Service Call</option>
                                        <option value="Training">Training</option>
                                        <option value="Meeting">Meeting</option>
                                        <option value="Delivery">Delivery</option>
                                        <option value="Other">Other</option>
                                    </select>
                                </div>
                            </form>
                        </div>

                        <!-- Route Builder -->
                        <div class="route-builder">
                            <div class="stops-section">
                                <div id="stops-list">
                                    <!-- Stop rows injected here by addStopAtIndex() / addStop() / removeStop() -->
                                </div>
                                <button class="add-stop-btn" onclick="addStop()" id="add-stop-btn">
                                    + Add Stop
                                    <span id="stop-count">2 locations • 1 legs</span>
                                </button>
                            </div>

                            <!-- Day Total: hidden until all legs have cached distances.
                                 commitTotalDistance() sums legs and shows this panel. -->
                            <div class="day-total" id="day-total" style="display: none;">
                                <div class="total-label">Day Total</div>
                                <div class="total-value" id="total-value">
                                    0.0<span class="total-unit">miles</span>
                                </div>
                                <div class="total-note">Add stops to see breakdown</div>
                            </div>

                            <!-- Map Preview: hidden until previewRoute() is called.
                                 toggleMapPreview() shows/hides it after the initial render.
                                 The #map-container div is the Google Maps mount point. -->
                            <div class="map-preview" id="map-preview" style="display: none;">
                                <div class="map-preview-header">
                                    <div class="map-preview-title">Route Preview</div>
                                    <button class="btn btn-clear" onclick="toggleMapPreview()" id="map-toggle-btn">
                                        Hide Map
                                    </button>
                                </div>
                                <div class="map-container" id="map-container">
                                    <div>Loading route preview...</div>
                                </div>
                            </div>

                            <!-- Action Buttons -->
                            <div class="action-buttons">
                                <button class="btn btn-clear" onclick="clearRoute()">Clear</button>
                                <button class="btn btn-preview" onclick="previewRoute()" id="preview-btn" disabled>
                                    Preview Route
                                </button>
                                <button class="btn btn-save" onclick="saveRoute()" id="save-btn" disabled>
                                    Save Route
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ═══════════════════════════════════════════════════
                     PAGE: HISTORY  (#history-page)
                     Reads all saved routes from localStorage, renders filter
                     dropdowns (month / purpose / status), and builds a data
                     table with date, route, miles, cost, and a delete button.
                     Filter dropdowns call filterHistory() on change.
                     Print buttons trigger printCurrentView() / printFilteredData().
                ════════════════════════════════════════════════════════ -->
                <div class="page" id="history-page">
                    <div class="page-header">
                        <h1 class="page-title">Trip History</h1>
                        <p class="page-subtitle">VIEW AND MANAGE YOUR SAVED ROUTES</p>
                    </div>
                    
                    <!-- Filters -->
                    <div class="route-card" style="margin-bottom: 20px;">
                        <div class="route-card-header">
                            <div class="section-title">Filters</div>
                            <div class="route-form" style="grid-template-columns: repeat(4, 1fr);">
                                <div class="form-field">
                                    <label>Month</label>
                                    <select id="filter-month" onchange="filterHistory()">
                                        <option value="">All Months</option>
                                    </select>
                                </div>
                                <div class="form-field">
                                    <label>Purpose</label>
                                    <select id="filter-purpose" onchange="filterHistory()">
                                        <option value="">All Purposes</option>
                                        <option value="Sales Visit">Sales Visit</option>
                                        <option value="Service Call">Service Call</option>
                                        <option value="Training">Training</option>
                                        <option value="Meeting">Meeting</option>
                                        <option value="Delivery">Delivery</option>
                                    </select>
                                </div>
                                <div class="form-field">
                                    <label>Status</label>
                                    <select id="filter-status" onchange="filterHistory()">
                                        <option value="">All</option>
                                        <option value="reimbursable">Reimbursable</option>
                                        <option value="non-reimbursable">Non-Reimbursable</option>
                                        <option value="synced">Synced</option>
                                        <option value="unsynced">Unsynced</option>
                                    </select>
                                </div>
                                <div class="form-field">
                                    <label>Actions</label>
                                    <button class="btn btn-preview" onclick="clearFilters()" style="width: 100%;">Clear Filters</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- History Table -->
                    <div class="route-card">
                        <div class="route-card-header">
                            <div class="section-title">Route History</div>
                        </div>
                        <div class="route-builder">
                            <!-- Print Section -->
                            <div class="print-section">
                                <h4 style="margin: 0 0 10px 0; color: #ffa726;">Print Reports</h4>
                                <button class="print-btn" onclick="printCurrentView()">🖨️ Print Current View</button>
                                <button class="print-btn" onclick="printFilteredData()">📄 Print Filtered Data</button>
                            </div>
                            
                            <div id="history-table-container">
                                <!-- Populated by renderHistoryTable() — one <tr> per saved route -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ═══════════════════════════════════════════════════
                     PAGE: LOCATIONS  (#locations-page)
                     Two sections:
                       • Add New Location form — name, address, type, lat/lng.
                         geocodeAddress() auto-fills lat/lng via Geocoding API.
                         addNewLocation() saves to localStorage + ALM_LOCATIONS.
                       • Location Directory grid — one card per location.
                         editLocation(key) / deleteCustomLocation(key) on each card.
                     Changes here update all stop-select dropdowns automatically.
                ════════════════════════════════════════════════════════ -->
                <div class="page" id="locations-page">
                    <div class="page-header">
                        <h1 class="page-title">Locations</h1>
                        <p class="page-subtitle">ALM DEALERSHIP AND OFFICE LOCATIONS</p>
                    </div>
                    
                    <!-- Add New Location -->
                    <div class="route-card" style="margin-bottom: 20px;">
                        <div class="route-card-header">
                            <div class="section-title">Add New Location</div>
                        </div>
                        <div class="route-builder">
                            <div class="route-form" style="grid-template-columns: repeat(3, 1fr); margin-bottom: 20px;">
                                <div class="form-field">
                                    <label>Location Name</label>
                                    <input type="text" id="new-location-name" placeholder="e.g., ALM Alpharetta">
                                </div>
                                <div class="form-field">
                                    <label>Full Address</label>
                                    <input type="text" id="new-location-address" placeholder="Street, City, State ZIP">
                                </div>
                                <div class="form-field">
                                    <label>Location Type</label>
                                    <select id="new-location-type">
                                        <option value="dealership">Dealership</option>
                                        <option value="corporate">Corporate Office</option>
                                        <option value="home">Home/Personal</option>
                                        <option value="other">Other</option>
                                    </select>
                                </div>
                            </div>
                            <div class="route-form" style="grid-template-columns: 1fr 1fr 1fr auto; align-items: end;">
                                <div class="form-field">
                                    <label>Latitude</label>
                                    <input type="number" id="new-location-lat" step="0.000001" placeholder="34.123456">
                                </div>
                                <div class="form-field">
                                    <label>Longitude</label>
                                    <input type="number" id="new-location-lng" step="0.000001" placeholder="-84.123456">
                                </div>
                                <div class="form-field">
                                    <button class="btn btn-secondary" onclick="geocodeAddress()" id="geocode-btn">
                                        📍 Get Coordinates
                                    </button>
                                </div>
                                <div class="form-field">
                                    <button class="btn btn-save" onclick="addNewLocation()">
                                        Add Location
                                    </button>
                                </div>
                            </div>
                            <div style="margin-top: 15px; padding: 10px; background: rgba(255, 167, 38, 0.1); border-radius: 4px; font-size: 13px; color: #ccc;">
                                💡 <strong>Tip:</strong> Enter the address and click "Get Coordinates" to automatically fill latitude/longitude, or find coordinates manually using Google Maps.
                            </div>
                        </div>
                    </div>
                    
                    <!-- Existing Locations -->
                    <div class="route-card">
                        <div class="route-card-header">
                            <div class="section-title">Location Directory</div>
                        </div>
                        <div class="route-builder">
                            <div id="locations-grid" class="locations-grid">
                                <!-- Populated by loadLocations() — one .location-card per entry -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ═══════════════════════════════════════════════════
                     PAGE: MATRIX  (#matrix-page)
                     Renders a location × location grid from the distance cache.
                     loadDistanceMatrix() builds the <table> and injects it into
                     #distance-matrix-container. Each data cell is clickable —
                     clicking calls matrixOpenSpotCheck(fromKey, toKey) to jump
                     to the Spot-Check page with that pair pre-filled.
                ════════════════════════════════════════════════════════ -->
                <div class="page" id="matrix-page">
                    <div class="page-header">
                        <h1 class="page-title">Distance Matrix</h1>
                        <p class="page-subtitle">LOCATION-TO-LOCATION DISTANCE GRID</p>
                    </div>
                    <div class="route-card">
                        <div class="route-card-header">
                            <div class="section-title">Distance Matrix</div>
                        </div>
                        <div class="route-builder">
                            <div id="distance-matrix-container" class="distance-matrix-container">
                                <!-- <table class="distance-matrix"> injected by loadDistanceMatrix() -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ═══════════════════════════════════════════════════
                     PAGE: CHARTS  (#charts-page)
                     Three sections rendered by loadCharts():
                       • Monthly Miles — Chart.js bar chart (#monthly-chart canvas)
                       • Purpose Breakdown — Chart.js doughnut (#purpose-chart canvas)
                       • Statistics Summary — stat cards grid (#stats-summary)
                     Existing Chart.js instances are destroyed before re-render
                     to avoid the "canvas already in use" error.
                ════════════════════════════════════════════════════════ -->
                <div class="page" id="charts-page">
                    <div class="page-header">
                        <h1 class="page-title">Charts</h1>
                        <p class="page-subtitle">MILEAGE ANALYTICS AND TRENDS</p>
                    </div>
                    
                    <!-- Charts Grid -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                        <div class="route-card">
                            <div class="route-card-header">
                                <div class="section-title">Monthly Miles</div>
                            </div>
                            <div class="route-builder">
                                <canvas id="monthly-chart" width="400" height="300"></canvas>
                            </div>
                        </div>
                        
                        <div class="route-card">
                            <div class="route-card-header">
                                <div class="section-title">Purpose Breakdown</div>
                            </div>
                            <div class="route-builder">
                                <canvas id="purpose-chart" width="400" height="300"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Stats Summary -->
                    <div class="route-card">
                        <div class="route-card-header">
                            <div class="section-title">Statistics Summary</div>
                        </div>
                        <div class="route-builder">
                            <div id="stats-summary" class="stats-grid">
                                <!-- Populated by updateStatsGrid() — one .stat-card per metric -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ═══════════════════════════════════════════════════
                     PAGE: COST  (#cost-page)
                     Rendered by loadCostReport(). Three summary cards:
                       • Total Miles  (#total-miles-card)
                       • Total Reimbursement at IRS rate  (#total-reimbursement-card)
                       • IRS Rate display  (#irs-rate-card)
                     Below: monthly breakdown table built by createMonthlyCostTable().
                     Print buttons trigger printCostReport() / printMonthlySummary().
                ════════════════════════════════════════════════════════ -->
                <div class="page" id="cost-page">
                    <div class="page-header">
                        <h1 class="page-title">Cost Report</h1>
                        <p class="page-subtitle">REIMBURSEMENT CALCULATIONS</p>
                    </div>
                    
                    <!-- Summary Cards -->
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-bottom: 20px;">
                        <div class="route-card">
                            <div class="route-builder" style="text-align: center; padding: 30px;">
                                <div style="font-size: 32px; font-weight: 700; color: #ffa726;" id="total-miles-card">0</div>
                                <div style="color: #666; margin-top: 8px; text-transform: uppercase; letter-spacing: 1px;">Total Miles</div>
                            </div>
                        </div>
                        
                        <div class="route-card">
                            <div class="route-builder" style="text-align: center; padding: 30px;">
                                <div style="font-size: 32px; font-weight: 700; color: #22c55e;" id="total-reimbursement-card">$0</div>
                                <div style="color: #666; margin-top: 8px; text-transform: uppercase; letter-spacing: 1px;">Total Reimbursement</div>
                            </div>
                        </div>
                        
                        <div class="route-card">
                            <div class="route-builder" style="text-align: center; padding: 30px;">
                                <div style="font-size: 32px; font-weight: 700; color: #ef4444;" id="irs-rate-card">$0.70</div>
                                <div style="color: #666; margin-top: 8px; text-transform: uppercase; letter-spacing: 1px;">IRS Rate/Mile</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Monthly Breakdown -->
                    <div class="route-card">
                        <div class="route-card-header">
                            <div class="section-title">Monthly Breakdown</div>
                        </div>
                        <div class="route-builder">
                            <!-- Print Section -->
                            <div class="print-section">
                                <h4 style="margin: 0 0 10px 0; color: #ffa726;">Print Cost Report</h4>
                                <button class="print-btn" onclick="printCostReport()">🖨️ Print Cost Report</button>
                                <button class="print-btn" onclick="printMonthlySummary()">📊 Print Monthly Summary</button>
                            </div>
                            
                            <div id="monthly-cost-table">
                                <!-- Populated by createMonthlyCostTable() — one section per month -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ═══════════════════════════════════════════════════
                     PAGE: DIST-REFRESH  (#dist-refresh-page)
                     Bulk-refreshes the distance cache via Directions API.
                     Layout (top → bottom):
                       • Sync Status Bar — Last Sync / Cache Entries / API / Health
                       • Action Buttons — Refresh All / Refresh Used / Clear Cache
                       • Terminal — live log output with blinking cursor
                       • Route Picker Section (#dr-picker-section, hidden until fetch)
                         ↳ Progress mini-bar (Fetched / Done / Remaining)
                         ↳ Save All Picked button (#dr-save-btn)
                         ↳ #dr-picker-list — one picker card per location pair
                     runDistanceRefresh(mode) drives the whole flow.
                ════════════════════════════════════════════════════════ -->
                <div class="page" id="dist-refresh-page">
                    <div class="page-header">
                        <h1 class="page-title">Distance Refresh</h1>
                        <p class="page-subtitle">CACHE MANAGEMENT & DISTANCE RECALCULATION</p>
                    </div>

                    <!-- Status Bar: four read-only metrics updated by updateDrStatusBar().
                         Values are read from localStorage (cache key + sync timestamp). -->
                    <div class="sync-status-bar">
                        <div class="sync-status-item">
                            <span class="sync-status-label">Last Sync</span>
                            <span class="sync-status-value" id="dr-last-sync">Never</span>
                        </div>
                        <div class="sync-divider"></div>
                        <div class="sync-status-item">
                            <span class="sync-status-label">Cache Entries</span>
                            <span class="sync-status-value" id="dr-cache-count">—</span>
                        </div>
                        <div class="sync-divider"></div>
                        <div class="sync-status-item">
                            <span class="sync-status-label">Maps API</span>
                            <span class="sync-status-value" id="dr-api-status">Checking…</span>
                        </div>
                        <div class="sync-divider"></div>
                        <div class="sync-status-item">
                            <span class="sync-status-label">Status</span>
                            <span class="sync-status-value" id="dr-sync-health">—</span>
                        </div>
                    </div>

                    <!-- Refresh buttons: all three disabled while a run is active
                         (drSetButtonsDisabled). Refresh Used counts only pairs that
                         appear in at least one saved route. -->
                    <div class="refresh-btn-group">
                        <button class="btn-refresh-all" id="dr-btn-all" onclick="runDistanceRefresh('all')">
                            ⟲ Refresh All Pairs (<span id="dr-pair-count">?</span>)
                        </button>
                        <button class="btn-refresh-used" id="dr-btn-used" onclick="runDistanceRefresh('used')">
                            ⟲ Refresh Used Routes Only
                        </button>
                        <button class="btn-clear-cache" id="dr-btn-clear" onclick="clearDistanceCache()">
                            ✕ Clear Cache Only
                        </button>
                    </div>

                    <!-- Terminal: output-only div. drLog(html) appends lines and
                         re-plants the blinking cursor. drTimestamp() prefixes each line. -->
                    <div class="terminal-wrap">
                        <div class="terminal-header">
                            <div class="terminal-dot red"></div>
                            <div class="terminal-dot yellow"></div>
                            <div class="terminal-dot green"></div>
                            <span class="terminal-title">alm-distance-refresh — bash</span>
                        </div>
                        <div class="terminal-body" id="dr-terminal">
                            <span class="t-dim">ALM Distance Refresh Terminal v1.9.4</span><br>
                            <span class="t-dim">── Ready. Choose a refresh option above to begin. ──</span><br>
                            <span class="t-cursor"></span>
                        </div>
                    </div>

                    <!-- Route Picker Results: revealed after runDistanceRefresh() fetches
                         all pairs. drRenderPickerCards() builds one card per pair.
                         drPickRoute() records a selection. drSaveAllPicked() commits all
                         choices to the cache and hides this section. -->
                    <div id="dr-picker-section" style="display:none; margin-top:24px;">
                        <div class="sync-status-bar" style="margin-bottom:16px;">
                            <div class="sync-status-item">
                                <span class="sync-status-label">Pairs Fetched</span>
                                <span class="sync-status-value" id="dr-picker-fetched">0</span>
                            </div>
                            <div class="sync-divider"></div>
                            <div class="sync-status-item">
                                <span class="sync-status-label">Selections Made</span>
                                <span class="sync-status-value" id="dr-picker-done">0</span>
                            </div>
                            <div class="sync-divider"></div>
                            <div class="sync-status-item">
                                <span class="sync-status-label">Remaining</span>
                                <span class="sync-status-value" id="dr-picker-remaining">0</span>
                            </div>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
                            <div style="font-size:11px; color:#666; font-family:'Courier New',monospace; text-transform:uppercase; letter-spacing:1px;">
                                Select your preferred route for each pair — shortest is Route 1
                            </div>
                            <button class="btn-refresh-all" id="dr-save-btn" onclick="drSaveAllPicked()" style="font-size:12px; padding:8px 20px;" disabled>
                                ✓ Save All Selections
                            </button>
                        </div>
                        <div id="dr-picker-list"></div>
                    </div>
                </div>

                <!-- ═══════════════════════════════════════════════════
                     PAGE: DIST-SPOTCHECK  (#dist-spotcheck-page)
                     Tests a single location pair against the live API.
                     Layout:
                       • spotcheck-form — start/end dropdowns + Run button
                       • #sc-result — result panel (hidden until check runs):
                           Route Pair / Cached Distance / Live Distance / Diff / Badge
                       • #sc-route-picker — inline picker to update cache
                       • Recent Checks log (#sc-log) — last 20 checks, session only
                     Can be jumped to directly from the Distance Matrix by clicking
                     any cell (matrixOpenSpotCheck pre-fills start/end and auto-runs).
                ════════════════════════════════════════════════════════ -->
                <div class="page" id="dist-spotcheck-page">
                    <div class="page-header">
                        <h1 class="page-title">Distance Spot-Check</h1>
                        <p class="page-subtitle">TEST A SINGLE PAIR WITHOUT BURNING API CALLS</p>
                    </div>

                    <div class="route-card">
                        <div class="route-card-header">
                            <div class="section-title">Check a Route Pair</div>
                        </div>
                        <div class="route-builder">
                            <div class="spotcheck-form">
                                <div class="form-field">
                                    <label>Start Location</label>
                                    <select id="sc-start" class="stop-select">
                                        <option value="">Choose start…</option>
                                    </select>
                                </div>
                                <div class="form-field">
                                    <label>End Location</label>
                                    <select id="sc-end" class="stop-select">
                                        <option value="">Choose end…</option>
                                    </select>
                                </div>
                                <div class="form-field">
                                    <button class="btn-refresh-all" onclick="runSpotCheck()" id="sc-btn" style="white-space:nowrap;">
                                        🔍 Check Distance
                                    </button>
                                </div>
                            </div>

                            <!-- Result panel: hidden (.spotcheck-result { display:none }) until
                                 runSpotCheck() resolves. scPickAndSave() updates the badge to SAVED. -->
                            <div class="spotcheck-result" id="sc-result">
                                <div class="spotcheck-row">
                                    <span class="spotcheck-key">Route Pair</span>
                                    <span class="spotcheck-val" id="sc-pair">—</span>
                                </div>
                                <div class="spotcheck-row">
                                    <span class="spotcheck-key">Cached Distance</span>
                                    <span class="spotcheck-val" id="sc-cached">—</span>
                                </div>
                                <div class="spotcheck-row">
                                    <span class="spotcheck-key">Live API Distance</span>
                                    <span class="spotcheck-val pending" id="sc-live">Fetching…</span>
                                </div>
                                <div class="spotcheck-row">
                                    <span class="spotcheck-key">Difference</span>
                                    <span class="spotcheck-val" id="sc-diff">—</span>
                                </div>
                                <div class="spotcheck-row" style="border-bottom:none; margin-top:8px;">
                                    <span class="spotcheck-key">Result</span>
                                    <span id="sc-badge"></span>
                                </div>
                            </div>

                            <!-- Route picker: shown after live fetch completes.
                                 One button per Directions API alternative, sorted shortest first.
                                 scPickAndSave() writes the chosen miles to cache on click. -->
                            <div id="sc-route-picker" style="display:none; margin-top:16px;">
                                <div style="font-size:11px; color:#888; font-family:'Courier New',monospace; text-transform:uppercase; letter-spacing:1px; margin-bottom:10px;">
                                    Pick a route to save to the Distance Matrix ↓
                                </div>
                                <div class="route-picker-options" id="sc-picker-options"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Check Log: session-only. renderScLog() rebuilds from the
                         in-memory scLog array (max 20 entries). clearSpotCheckLog() resets it. -->
                    <div class="route-card" style="margin-top:20px;">
                        <div class="route-card-header">
                            <div style="display:flex; justify-content:space-between; align-items:center; width:100%;">
                                <div class="section-title" style="margin-bottom:0;">Recent Checks</div>
                                <button class="btn btn-clear" style="font-size:11px; padding:6px 14px;" onclick="clearSpotCheckLog()">Clear Log</button>
                            </div>
                        </div>
                        <div class="route-builder">
                            <div id="sc-log">
                                <div style="color:#555; font-size:13px; font-family:'Courier New',monospace;">No checks run yet.</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ═══════════════════════════════════════════════════
                     PAGE: CHANGELOG  (#changelog-page)
                     Version history rendered by loadChangelog(). The changelog
                     array lives inside that function — add new entries at the TOP.
                     Each entry: { version, date, features: [...] }
                ════════════════════════════════════════════════════════ -->
                <div class="page" id="changelog-page">
                    <div class="page-header">
                        <h1 class="page-title">Changelog</h1>
                        <p class="page-subtitle">VERSION HISTORY AND UPDATES</p>
                    </div>
                    <div class="route-card">
                        <div class="route-card-header">
                            <div class="section-title">Version History</div>
                        </div>
                        <div class="route-builder">
                            <div id="changelog-content" class="changelog-content">
                                <!-- Populated by loadChangelog() — one .changelog-version div per release -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- ═══════════════════════════════════════════════════════════════
         CONFLICT RESOLUTION MODAL  (#conflict-modal)
         Fixed overlay, hidden by default (.modal-overlay { display:none }).
         showConflictModal() adds .show to make it visible.
         The #conflicts-list is populated by createConflictElement() — one
         card per conflict with Overwrite / Skip / Keep Both buttons.
         Footer has bulk-resolve buttons and the Proceed button (#proceed-btn),
         which is disabled until updateConflictsRemaining() reaches 0.
    ════════════════════════════════════════════════════════════════════ -->
    <div class="modal-overlay" id="conflict-modal">
        <div class="conflict-modal">
            <div class="modal-header">
                <h2 class="modal-title">Import Conflicts Detected</h2>
                <div class="modal-subtitle">Resolve data conflicts before importing</div>
            </div>
            <div class="modal-body">
                <div class="conflicts-list" id="conflicts-list">
                    <!-- Populated by createConflictElement() — one card per conflict -->
                </div>
            </div>
            <div class="modal-footer">
                <div class="conflicts-summary">
                    <span id="conflicts-remaining">0</span> conflicts remaining
                </div>
                <div class="bulk-actions">
                    <button class="btn btn-clear" onclick="cancelImport()">Cancel Import</button>
                    <button class="conflict-btn skip" onclick="bulkResolve('skip')">Skip All</button>
                    <button class="conflict-btn overwrite" onclick="bulkResolve('overwrite')">Overwrite All</button>
                    <button class="btn btn-preview" onclick="proceedWithImport()" id="proceed-btn" disabled>
                        Proceed with Import
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- ═══════════════════════════════════════════════════════════════
         EXTERNAL SCRIPTS
         Load order matters:
           1. Google Maps JS API (async/defer, callback=initMap)
           2. Chart.js          (synchronous, needed before loadCharts())
           3. SheetJS (xlsx)    (synchronous, needed before importExcel())
           4. Main app script   (inline <script> block — all app code)
    ════════════════════════════════════════════════════════════════════ -->
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBjlBfZykUSXuKi-O3OGJ4YTfiI4H3CpdE&callback=initMap&libraries=geometry"></script>
    
    <!-- Chart.js for analytics -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- SheetJS for Excel import/export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <script>
        // ════════════════════════════════════════════════════════════════════
        //  CONSTANTS & GLOBAL STATE
        //  App-wide constants, location data, and mutable runtime variables.
        // ════════════════════════════════════════════════════════════════════

        // Constants
        const MAX_STOPS = 6;
        const GOOGLE_API_KEY = 'AIzaSyBjlBfZykUSXuKi-O3OGJ4YTfiI4H3CpdE';
        const IRS_RATE = 0.70; // $0.70 per mile for 2025
        
        // ALM Locations (verified coordinates)
        const ALM_LOCATIONS = {
            'home': {
                name: 'Home',
                address: '216 Winterbury Dr, Canton, GA 30114',
                lat: 34.2364,
                lng: -84.4903,
                type: 'home'
            },
            'corporate': {
                name: 'ALM Corporate',
                address: '6625 The Corners Pkwy NW, Norcross, GA 30092',
                lat: 33.9410,
                lng: -84.2140,
                type: 'corporate'
            },
            'kennesaw': {
                name: 'ALM Kennesaw',
                address: '3905 Cherokee St NW, Kennesaw, GA 30144',
                lat: 34.0234,
                lng: -84.6199,
                type: 'dealership'
            },
            'marietta': {
                name: 'ALM Marietta',
                address: '750 Cobb Pkwy S, Marietta, GA 30060',
                lat: 33.9370,
                lng: -84.5220,
                type: 'dealership'
            },
            'gwinnett': {
                name: 'ALM Gwinnett',
                address: '2520 Pleasant Hill Rd, Duluth, GA 30096',
                lat: 33.9567,
                lng: -84.1442,
                type: 'dealership'
            },
            'buford': {
                name: 'ALM Buford',
                address: '4805 Browns Bridge Rd, Buford, GA 30518',
                lat: 34.1212,
                lng: -83.9932,
                type: 'dealership'
            },
            'roswell': {
                name: 'ALM Roswell',
                address: '11205 Alpharetta Hwy, Roswell, GA 30076',
                lat: 34.0754,
                lng: -84.3052,
                type: 'dealership'
            },
            'newnan': {
                name: 'ALM Newnan',
                address: '1405 Newnan Crossing Bypass, Newnan, GA 30265',
                lat: 33.3668,
                lng: -84.7796,
                type: 'dealership'
            },
            'mcdonough': {
                name: 'ALM McDonough',
                address: '1550 Highway 20/81 E, McDonough, GA 30253',
                lat: 33.4734,
                lng: -84.1468,
                type: 'dealership'
            }
        };

        // Global variables
        let currentRoute = [];
        let totalDistance = 0;
        let map = null;
        let directionsService = null;
        let directionsRenderer = null;
        let isMapInitialized = false;
        let importConflicts = [];
        let conflictResolutions = {};

        // ════════════════════════════════════════════════════════════════════
        //  IMPORT CONFLICT RESOLUTION
        //  Detect, display, and resolve conflicts when importing Excel data.
        // ════════════════════════════════════════════════════════════════════

        // Compares incoming routes against existing saved routes and returns
                // an array of conflict objects where dates and mileage overlap.
        function detectConflicts(newRoutes, existingRoutes) {
            const conflicts = [];
            const existingByDate = {};
            
            // Index existing routes by date for fast lookup
            existingRoutes.forEach(route => {
                if (!existingByDate[route.date]) {
                    existingByDate[route.date] = [];
                }
                existingByDate[route.date].push(route);
            });
            
            // Check each new route for conflicts
            newRoutes.forEach((newRoute, index) => {
                const existingForDate = existingByDate[newRoute.date];
                if (existingForDate && existingForDate.length > 0) {
                    // Found conflict(s) for this date
                    existingForDate.forEach(existing => {
                        conflicts.push({
                            id: `conflict_${index}_${existing.id}`,
                            date: newRoute.date,
                            existing: existing,
                            incoming: newRoute,
                            resolution: null,
                            adjustedDate: newRoute.date
                        });
                    });
                }
            });
            
            return conflicts;
        }

        // Renders the conflict resolution modal with all detected conflicts
                // and makes it visible on screen.
        function showConflictModal(conflicts) {
            importConflicts = conflicts;
            conflictResolutions = {};
            
            const modal = document.getElementById('conflict-modal');
            const conflictsList = document.getElementById('conflicts-list');
            
            conflictsList.innerHTML = '';
            
            conflicts.forEach(conflict => {
                const conflictElement = createConflictElement(conflict);
                conflictsList.appendChild(conflictElement);
            });
            
            updateConflictsRemaining();
            modal.classList.add('show');
        }

        // Builds the HTML for a single conflict card — shows existing vs
                // incoming data side-by-side with Overwrite / Skip / Keep Both buttons.
        function createConflictElement(conflict) {
            const div = document.createElement('div');
            div.className = 'conflict-item';
            div.dataset.conflictId = conflict.id;
            
            // Suggest next available date
            const suggestedDate = findNextAvailableDate(conflict.date);
            conflict.adjustedDate = suggestedDate;
            
            div.innerHTML = `
                <div class="conflict-header">
                    <div class="conflict-date">${formatDate(conflict.date)}</div>
                    <div class="conflict-indicator">Conflict</div>
                </div>
                <div class="conflict-comparison">
                    <div class="conflict-side">
                        <h4>Existing Data</h4>
                        <div class="conflict-detail">
                            <span class="conflict-label">Purpose:</span>
                            <span class="conflict-value">${conflict.existing.purpose}</span>
                        </div>
                        <div class="conflict-detail">
                            <span class="conflict-label">Route:</span>
                            <span class="conflict-value">${formatRoute(conflict.existing.stops)}</span>
                        </div>
                        <div class="conflict-detail">
                            <span class="conflict-label">Miles:</span>
                            <span class="conflict-value">${conflict.existing.totalMiles}</span>
                        </div>
                        <div class="conflict-detail">
                            <span class="conflict-label">Cost:</span>
                            <span class="conflict-value">$${conflict.existing.cost.toFixed(2)}</span>
                        </div>
                    </div>
                    <div class="conflict-side">
                        <h4>Incoming Data</h4>
                        <div class="conflict-detail">
                            <span class="conflict-label">Purpose:</span>
                            <span class="conflict-value">${conflict.incoming.purpose}</span>
                        </div>
                        <div class="conflict-detail">
                            <span class="conflict-label">Route:</span>
                            <span class="conflict-value">${formatRoute(conflict.incoming.stops)}</span>
                        </div>
                        <div class="conflict-detail">
                            <span class="conflict-label">Miles:</span>
                            <span class="conflict-value">${conflict.incoming.totalMiles}</span>
                        </div>
                        <div class="conflict-detail">
                            <span class="conflict-label">Cost:</span>
                            <span class="conflict-value">$${conflict.incoming.cost.toFixed(2)}</span>
                        </div>
                    </div>
                </div>
                <div class="conflict-actions">
                    <div class="date-adjustment">
                        <label>Adjust Date:</label>
                        <input type="date" value="${suggestedDate}" onchange="updateAdjustedDate('${conflict.id}', this.value)">
                    </div>
                    <button class="conflict-btn overwrite" onclick="resolveConflict('${conflict.id}', 'overwrite')">
                        Overwrite
                    </button>
                    <button class="conflict-btn skip" onclick="resolveConflict('${conflict.id}', 'skip')">
                        Skip
                    </button>
                    <button class="conflict-btn keep-both" onclick="resolveConflict('${conflict.id}', 'keep-both')">
                        Keep Both
                    </button>
                </div>
            `;
            
            return div;
        }

        // Starting from originalDate, finds the next calendar date that does
                // not already have a saved route (used by Keep Both mode).
        function findNextAvailableDate(originalDate) {
            const existingRoutes = JSON.parse(localStorage.getItem('alm_routes') || '[]');
            const existingDates = new Set(existingRoutes.map(r => r.date));
            
            let testDate = new Date(originalDate + 'T00:00:00');
            testDate.setDate(testDate.getDate() + 1); // Start with next day
            
            // Find next available date (up to 30 days ahead)
            for (let i = 0; i < 30; i++) {
                const testDateStr = testDate.toISOString().split('T')[0];
                if (!existingDates.has(testDateStr)) {
                    return testDateStr;
                }
                testDate.setDate(testDate.getDate() + 1);
            }
            
            // If no available date found in 30 days, just return tomorrow
            testDate = new Date(originalDate + 'T00:00:00');
            testDate.setDate(testDate.getDate() + 1);
            return testDate.toISOString().split('T')[0];
        }

        // Converts a YYYY-MM-DD string to a human-readable date like "Feb 18, 2026".
        function formatDate(dateStr) {
            const date = new Date(dateStr + 'T00:00:00');
            return date.toLocaleDateString('en-US', { 
                weekday: 'short', 
                year: 'numeric', 
                month: 'short', 
                day: 'numeric' 
            });
        }

        // Joins an array of stop objects into a readable string like
                // "Home → ALM Kennesaw → ALM Corporate".
        function formatRoute(stops) {
            if (!stops || stops.length === 0) return 'No route';
            if (stops.length === 1) return stops[0].name;
            if (stops.length === 2) return `${stops[0].name} → ${stops[1].name}`;
            return `${stops[0].name} → ... → ${stops[stops.length - 1].name} (${stops.length} stops)`;
        }

        // Updates the proposed adjusted date for a Keep Both conflict when
                // the user manually changes the date input in the conflict card.
        function updateAdjustedDate(conflictId, newDate) {
            const conflict = importConflicts.find(c => c.id === conflictId);
            if (conflict) {
                conflict.adjustedDate = newDate;
                
                // If date is changed and resolution was 'keep-both', automatically apply it
                if (newDate !== conflict.date && conflictResolutions[conflictId] !== 'keep-both') {
                    resolveConflict(conflictId, 'keep-both');
                }
            }
        }

        // Records the user's resolution choice (overwrite / skip / keep-both)
                // for a specific conflict and updates the card's visual state.
        function resolveConflict(conflictId, resolution) {
            const conflict = importConflicts.find(c => c.id === conflictId);
            if (!conflict) return;
            
            conflictResolutions[conflictId] = resolution;
            conflict.resolution = resolution;
            
            // Update UI to show resolution
            const conflictElement = document.querySelector(`[data-conflict-id="${conflictId}"]`);
            if (conflictElement) {
                // Remove previous resolution classes
                conflictElement.classList.remove('resolved-overwrite', 'resolved-skip', 'resolved-keep-both');
                
                // Add new resolution class
                conflictElement.classList.add(`resolved-${resolution}`);
                
                // Update conflict indicator
                const indicator = conflictElement.querySelector('.conflict-indicator');
                const resolutionText = {
                    'overwrite': 'Will Overwrite',
                    'skip': 'Will Skip',
                    'keep-both': 'Will Keep Both'
                };
                indicator.textContent = resolutionText[resolution];
                indicator.style.background = {
                    'overwrite': '#ef4444',
                    'skip': '#666',
                    'keep-both': '#22c55e'
                }[resolution];
            }
            
            updateConflictsRemaining();
        }

        // Applies the same resolution to every unresolved conflict at once
                // (used by the Skip All and Overwrite All buttons).
        function bulkResolve(resolution) {
            importConflicts.forEach(conflict => {
                if (!conflictResolutions[conflict.id]) {
                    resolveConflict(conflict.id, resolution);
                }
            });
            
            showToast(`Applied "${resolution}" to all unresolved conflicts`, 'success');
        }

        // Counts unresolved conflicts and updates the counter in the modal footer.
                // Enables the Proceed button once all conflicts have a resolution.
        function updateConflictsRemaining() {
            const resolved = Object.keys(conflictResolutions).length;
            const remaining = importConflicts.length - resolved;
            
            document.getElementById('conflicts-remaining').textContent = remaining;
            document.getElementById('proceed-btn').disabled = remaining > 0;
        }

        // Hides the conflict modal and discards all pending import data
                // without writing anything to localStorage.
        function cancelImport() {
            const modal = document.getElementById('conflict-modal');
            modal.classList.remove('show');
            importConflicts = [];
            conflictResolutions = {};
            showToast('Import cancelled', 'warning');
        }

        // Applies all resolved conflicts (merge, skip, or date-shift) and
                // writes the final set of imported routes to localStorage.
        function proceedWithImport() {
            // Apply all resolutions and import the data
            const existingRoutes = JSON.parse(localStorage.getItem('alm_routes') || '[]');
            let finalRoutes = [...existingRoutes];
            let addedCount = 0;
            let overwrittenCount = 0;
            let skippedCount = 0;
            
            importConflicts.forEach(conflict => {
                const resolution = conflictResolutions[conflict.id];
                
                switch (resolution) {
                    case 'overwrite':
                        // Replace existing entry with new one
                        const existingIndex = finalRoutes.findIndex(r => r.id === conflict.existing.id);
                        if (existingIndex !== -1) {
                            finalRoutes[existingIndex] = {
                                ...conflict.incoming,
                                id: conflict.existing.id // Keep original ID
                            };
                            overwrittenCount++;
                        }
                        break;
                        
                    case 'skip':
                        // Do nothing - skip the incoming entry
                        skippedCount++;
                        break;
                        
                    case 'keep-both':
                        // Add new entry with adjusted date if needed
                        const newEntry = {
                            ...conflict.incoming,
                            date: conflict.adjustedDate,
                            id: Date.now().toString() + Math.random().toString(36).substr(2, 9)
                        };
                        finalRoutes.push(newEntry);
                        addedCount++;
                        break;
                }
            });
            
            // Save the final routes
            localStorage.setItem('alm_routes', JSON.stringify(finalRoutes));
            
            // Close modal and show success message
            const modal = document.getElementById('conflict-modal');
            modal.classList.remove('show');
            
            const summary = [];
            if (addedCount > 0) summary.push(`${addedCount} added`);
            if (overwrittenCount > 0) summary.push(`${overwrittenCount} overwritten`);
            if (skippedCount > 0) summary.push(`${skippedCount} skipped`);
            
            showToast(`Import completed: ${summary.join(', ')}`, 'success');
            
            // Reset conflict state
            importConflicts = [];
            conflictResolutions = {};
        }

        // ════════════════════════════════════════════════════════════════════
        //  APP INIT & NAVIGATION
        //  Bootstrap the app on DOMContentLoaded, set up nav click handlers,
        //  and route each page to its initialization function.
        // ════════════════════════════════════════════════════════════════════

        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
            checkDraft();
            updateStatus();
        });

        // Entry point called on DOMContentLoaded. Sets today's date, loads
                // custom locations, builds the default route, wires up nav and auto-save.
        function initializeApp() {
            // Set today's date
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('trip-date').value = today;
            
            // Load custom locations into ALM_LOCATIONS
            loadCustomLocationsIntoMemory();

            // Initialize route with 3 stops: START > STOP 1 > END
            initializeDefaultRoute();
            
            // Setup navigation
            setupNavigation();
            
            // Auto-save on changes
            setupAutoSave();
            
            // Initialize the current active page content
            const activePage = document.querySelector('.nav-item.active');
            if (activePage && activePage.dataset.page) {
                initializePage(activePage.dataset.page);
            }
        }

        // Reads any user-added locations from localStorage and merges them
                // into the global ALM_LOCATIONS object so they appear everywhere.
        function loadCustomLocationsIntoMemory() {
            const customLocations = JSON.parse(localStorage.getItem('alm_custom_locations') || '{}');
            Object.assign(ALM_LOCATIONS, customLocations);
        }

        // ════════════════════════════════════════════════════════════════════
        //  PRINT FUNCTIONS
        //  Trigger print dialogs for the current view, filtered data, or cost reports.
        // ════════════════════════════════════════════════════════════════════

        // Stamps today's date onto the page header for the print header,
                // then triggers window.print().
        function printCurrentView() {
            // Set print date attribute
            const pageHeader = document.querySelector('.page-header');
            if (pageHeader) {
                pageHeader.setAttribute('data-print-date', new Date().toLocaleDateString());
            }
            
            window.print();
        }

        // Only prints if filters are active on the History page; otherwise
                // nudges the user to use Print Current View instead.
        function printFilteredData() {
            // For history page, ensure we're showing filtered data
            if (document.getElementById('history-page').classList.contains('active')) {
                const hasFilters = document.getElementById('filter-month').value || 
                                  document.getElementById('filter-purpose').value || 
                                  document.getElementById('filter-status').value;
                
                if (!hasFilters) {
                    showToast('No filters applied. Use "Print Current View" instead.', 'warning');
                    return;
                }
            }
            
            printCurrentView();
        }

        // Navigates to the Cost Report page if not already there, then
                // triggers a print after a short delay to allow the page to load.
        function printCostReport() {
            // Switch to cost page if not already there
            const costPage = document.getElementById('cost-page');
            if (!costPage.classList.contains('active')) {
                document.querySelector('.nav-item[data-page="cost"]').click();
                setTimeout(printCurrentView, 500); // Wait for page to load
            } else {
                printCurrentView();
            }
        }

        // Alias for printCostReport — both produce the same output for now.
        function printMonthlySummary() {
            printCostReport(); // Same as cost report for now
        }

        // Resets the stop list and adds the default two-stop layout:
                // START (auto-selected to Home) and STOP 1 - END (empty).
        function initializeDefaultRoute() {
            // Clear any existing route
            currentRoute = [];
            document.getElementById('stops-list').innerHTML = '';
            
            // Add START stop (Home)
            addStopAtIndex(0, 'start', 'START', true);
            
            // Add middle stop (empty)
            addStopAtIndex(1, 'end', 'STOP 1 - END', false);
            
            // Update counters and buttons
            updateStopCounter();
            updateAddStopButton();
        }

        // Creates a single stop row DOM element at the given index, appends
                // it to the stop list, and optionally auto-selects Home.
        function addStopAtIndex(index, indicatorClass, labelText, autoSelectHome) {
            const stopsList = document.getElementById('stops-list');
            
            const stopItem = document.createElement('div');
            stopItem.className = 'stop-item';
            stopItem.dataset.index = index;
            
            stopItem.innerHTML = `
                <div class="stop-indicator ${indicatorClass}"></div>
                <div class="stop-label">${labelText}</div>
                <select class="stop-select" onchange="updateRoute(${index})">
                    <option value="">Choose location...</option>
                    ${Object.entries(ALM_LOCATIONS).map(([key, loc]) => 
                        `<option value="${key}">${loc.name}</option>`
                    ).join('')}
                </select>
                <div class="stop-distance" style="display: none;">0 mi</div>
                ${index > 0 ? `<button class="stop-remove" onclick="removeStop(${index})">×</button>` : ''}
            `;
            
            stopsList.appendChild(stopItem);
            currentRoute.push({ location: null, distance: 0 });
            
            // Auto-select Home for first stop
            if (autoSelectHome) {
                const select = stopItem.querySelector('select');
                select.value = 'home';
                currentRoute[index].location = 'home';
            }
        }

        // Attaches click listeners to every sidebar nav item. On click:
                // swaps active classes on nav items and pages, then calls initializePage().
        function setupNavigation() {
            const navItems = document.querySelectorAll('.nav-item[data-page]');
            const pages = document.querySelectorAll('.page');

            navItems.forEach(item => {
                item.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetPage = item.dataset.page;
                    
                    // Update active nav item
                    navItems.forEach(i => i.classList.remove('active'));
                    item.classList.add('active');
                    
                    // Update active page
                    pages.forEach(page => page.classList.remove('active'));
                    const pageElement = document.getElementById(`${targetPage}-page`);
                    if (pageElement) {
                        pageElement.classList.add('active');
                        
                        // Initialize page-specific content
                        initializePage(targetPage);
                    }
                });
            });
        }

        // Router — called whenever a page becomes active. Dispatches to the
                // correct load function (loadTripHistory, loadCharts, etc.) by page name.
        function initializePage(pageType) {
            switch(pageType) {
                case 'history':
                    loadTripHistory();
                    break;
                case 'locations':
                    loadLocations();
                    break;
                case 'matrix':
                    loadDistanceMatrix();
                    break;
                case 'charts':
                    loadCharts();
                    break;
                case 'cost':
                    loadCostReport();
                    break;
                case 'changelog':
                    loadChangelog();
                    break;
                case 'dist-refresh':
                    initDistRefreshPage();
                    break;
                case 'dist-spotcheck':
                    initSpotCheckPage();
                    break;
            }
        }

        // ════════════════════════════════════════════════════════════════════
        //  TRIP HISTORY
        //  Load, filter, render, and delete saved routes from localStorage.
        // ════════════════════════════════════════════════════════════════════

        // Reads all saved routes, populates the month filter dropdown,
                // applies active filters, and renders the history table.
        function loadTripHistory() {
            const routes = JSON.parse(localStorage.getItem('alm_routes') || '[]');
            const container = document.getElementById('history-table-container');

            // Populate month filter dynamically from actual saved route dates
            populateMonthFilter(routes);

            if (routes.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">No trips recorded yet</p>';
                return;
            }
            
            const filteredRoutes = applyHistoryFilters(routes);
            renderHistoryTable(filteredRoutes);
        }

        // Extracts unique YYYY-MM values from all route dates and rebuilds
                // the month dropdown sorted newest first.
        function populateMonthFilter(routes) {
            const select = document.getElementById('filter-month');
            if (!select) return;
            const currentValue = select.value;

            // Collect unique YYYY-MM values from all saved routes, sorted newest first
            const months = [...new Set(routes.map(r => r.date.substring(0, 7)))]
                .filter(Boolean)
                .sort()
                .reverse();

            select.innerHTML = '<option value="">All Months</option>' + months.map(m => {
                const [year, month] = m.split('-');
                const label = new Date(parseInt(year), parseInt(month) - 1, 1)
                    .toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                return `<option value="${m}" ${m === currentValue ? 'selected' : ''}>${label}</option>`;
            }).join('');
        }

        // Filters the routes array by the active month, purpose, and
                // status dropdown selections.
        function applyHistoryFilters(routes) {
            const monthFilter = document.getElementById('filter-month')?.value;
            const purposeFilter = document.getElementById('filter-purpose')?.value;
            const statusFilter = document.getElementById('filter-status')?.value;
            
            return routes.filter(route => {
                const routeMonth = route.date.substring(0, 7); // YYYY-MM
                
                if (monthFilter && routeMonth !== monthFilter) return false;
                if (purposeFilter && route.purpose !== purposeFilter) return false;
                if (statusFilter) {
                    if (statusFilter === 'reimbursable' && !route.reimbursable) return false;
                    if (statusFilter === 'non-reimbursable' && route.reimbursable) return false;
                    if (statusFilter === 'synced' && !route.synced) return false;
                    if (statusFilter === 'unsynced' && route.synced) return false;
                }
                
                return true;
            });
        }

        // Builds and injects the full history <table> from the filtered
                // routes array.
        function renderHistoryTable(routes) {
            const container = document.getElementById('history-table-container');
            
            const table = document.createElement('table');
            table.className = 'data-table';
            
            table.innerHTML = `
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Purpose</th>
                        <th>Route</th>
                        <th>Miles</th>
                        <th>Cost</th>
                        <th>Status</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    ${routes.map(route => `
                        <tr>
                            <td>${formatDate(route.date)}</td>
                            <td>${route.purpose}</td>
                            <td>${formatRoute(route.stops)}</td>
                            <td>${route.totalMiles?.toFixed(1) || '0'}</td>
                            <td>$${route.cost?.toFixed(2) || '0.00'}</td>
                            <td>
                                <span class="status-badge ${route.reimbursable ? 'reimbursable' : 'non-reimbursable'}">
                                    ${route.reimbursable ? 'Reimbursable' : 'Non-Reimbursable'}
                                </span>
                                <span class="status-badge ${route.synced ? 'synced' : 'unsynced'}">
                                    ${route.synced ? 'Synced' : 'Unsynced'}
                                </span>
                            </td>
                            <td>
                                <button class="conflict-btn skip" onclick="deleteRoute('${route.id}')" style="padding: 4px 8px; font-size: 10px;">Delete</button>
                            </td>
                        </tr>
                    `).join('')}
                </tbody>
            `;
            
            container.innerHTML = '';
            container.appendChild(table);
        }

        // Triggered by any filter dropdown change — simply reloads the
                // history page with current filter values applied.
        function filterHistory() {
            loadTripHistory();
        }

        // Resets all filter dropdowns to "All" and reloads the history.
        function clearFilters() {
            document.getElementById('filter-month').value = '';
            document.getElementById('filter-purpose').value = '';
            document.getElementById('filter-status').value = '';
            loadTripHistory();
        }

        // Prompts for confirmation, removes the route with the matching id
                // from localStorage, and reloads the history table.
        function deleteRoute(routeId) {
            if (!confirm('Are you sure you want to delete this route?')) return;
            
            const routes = JSON.parse(localStorage.getItem('alm_routes') || '[]');
            const updatedRoutes = routes.filter(r => r.id !== routeId);
            localStorage.setItem('alm_routes', JSON.stringify(updatedRoutes));
            
            showToast('Route deleted', 'success');
            loadTripHistory();
        }

        // ════════════════════════════════════════════════════════════════════
        //  LOCATIONS MANAGEMENT
        //  Display the location directory, add/edit/delete custom locations,
        //  geocode addresses, and sync changes to all dropdowns.
        // ════════════════════════════════════════════════════════════════════

        // Merges ALM_LOCATIONS with custom locations from localStorage and
                // renders a card grid with Edit and Delete buttons.
        function loadLocations() {
            const container = document.getElementById('locations-grid');
            
            // Get custom locations from localStorage
            const customLocations = JSON.parse(localStorage.getItem('alm_custom_locations') || '{}');
            
            // Combine ALM locations with custom locations
            const allLocations = { ...ALM_LOCATIONS, ...customLocations };
            
            const locationCards = Object.entries(allLocations).map(([key, location]) => {
                const isCustom = !ALM_LOCATIONS[key] || customLocations[key]; // Include edited built-in locations
                const isOriginalALM = ALM_LOCATIONS[key] && !customLocations[key];
                
                return `
                    <div class="location-card" id="location-card-${key}">
                        <div class="location-name">${location.name} ${isCustom && !isOriginalALM ? '(Custom)' : ''}</div>
                        <div class="location-type ${location.type}">${location.type}</div>
                        <div class="location-address">${location.address}</div>
                        <div class="location-coords">${location.lat.toFixed(6)}, ${location.lng.toFixed(6)}</div>
                        <div style="margin-top: 10px; display: flex; gap: 5px;">
                            <button class="conflict-btn keep-both" onclick="editLocation('${key}')" style="padding: 4px 8px; font-size: 10px;">Edit</button>
                            ${isCustom && !isOriginalALM ? `<button class="conflict-btn skip" onclick="deleteCustomLocation('${key}')" style="padding: 4px 8px; font-size: 10px;">Delete</button>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
            
            container.innerHTML = locationCards;
        }

        // Calls the Google Maps Geocoding API with the address field value
                // and auto-fills the lat/lng inputs on success.
        async function geocodeAddress() {
            const address = document.getElementById('new-location-address').value.trim();
            
            if (!address) {
                showToast('Please enter an address first', 'warning');
                return;
            }
            
            const geocodeBtn = document.getElementById('geocode-btn');
            geocodeBtn.disabled = true;
            geocodeBtn.textContent = '🔄 Getting...';
            
            try {
                // Check if Google Maps and Geocoder are available
                if (typeof google === 'undefined' || !google.maps || !google.maps.Geocoder) {
                    throw new Error('Google Maps Geocoding API not available');
                }
                
                // Use Google Maps Geocoding API
                const geocoder = new google.maps.Geocoder();
                
                const result = await new Promise((resolve, reject) => {
                    geocoder.geocode({ address: address }, (results, status) => {
                        if (status === 'OK' && results[0]) {
                            resolve(results[0]);
                        } else {
                            reject(new Error(`Geocoding failed: ${status}`));
                        }
                    });
                });
                
                const location = result.geometry.location;
                document.getElementById('new-location-lat').value = location.lat().toFixed(6);
                document.getElementById('new-location-lng').value = location.lng().toFixed(6);
                
                showToast('Coordinates found successfully', 'success');
                
            } catch (error) {
                console.error('Geocoding error:', error);
                
                // Provide helpful guidance based on error type
                if (error.message.includes('not available')) {
                    showToast('Geocoding API not enabled. Please enter coordinates manually or enable Geocoding API in Google Cloud Console.', 'warning');
                } else if (error.message.includes('ZERO_RESULTS')) {
                    showToast('Address not found. Please check the address and try again.', 'warning');
                } else if (error.message.includes('OVER_QUERY_LIMIT')) {
                    showToast('API quota exceeded. Please try again later or enter coordinates manually.', 'error');
                } else {
                    showToast('Could not find coordinates. Please enter manually.', 'error');
                }
                
                // Show manual entry tip
                showToast('Tip: You can find coordinates by searching the address on Google Maps and right-clicking the location.', 'warning');
            } finally {
                geocodeBtn.disabled = false;
                geocodeBtn.textContent = '📍 Get Coordinates';
            }
        }

        // Validates the new location form, generates a unique key, saves
                // to localStorage and ALM_LOCATIONS, then refreshes all dropdowns.
        function addNewLocation() {
            const name = document.getElementById('new-location-name').value.trim();
            const address = document.getElementById('new-location-address').value.trim();
            const type = document.getElementById('new-location-type').value;
            const lat = parseFloat(document.getElementById('new-location-lat').value);
            const lng = parseFloat(document.getElementById('new-location-lng').value);
            
            // Validation
            if (!name || !address || !type) {
                showToast('Please fill in all required fields', 'warning');
                return;
            }
            
            if (isNaN(lat) || isNaN(lng)) {
                showToast('Please provide valid coordinates', 'warning');
                return;
            }
            
            if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                showToast('Coordinates are out of valid range', 'error');
                return;
            }
            
            // Generate unique key
            const key = 'custom_' + name.toLowerCase().replace(/[^a-z0-9]/g, '_').substring(0, 20) + '_' + Date.now();
            
            // Check if location already exists
            const customLocations = JSON.parse(localStorage.getItem('alm_custom_locations') || '{}');
            const allLocations = { ...ALM_LOCATIONS, ...customLocations };
            
            const existingLocation = Object.values(allLocations).find(loc => 
                loc.name.toLowerCase() === name.toLowerCase() ||
                (Math.abs(loc.lat - lat) < 0.001 && Math.abs(loc.lng - lng) < 0.001)
            );
            
            if (existingLocation) {
                showToast('A location with this name or coordinates already exists', 'warning');
                return;
            }
            
            // Create new location
            const newLocation = {
                name: name,
                address: address,
                lat: lat,
                lng: lng,
                type: type
            };
            
            // Save to localStorage
            customLocations[key] = newLocation;
            localStorage.setItem('alm_custom_locations', JSON.stringify(customLocations));
            
            // Update ALM_LOCATIONS for immediate use
            ALM_LOCATIONS[key] = newLocation;
            
            // Clear form
            document.getElementById('new-location-name').value = '';
            document.getElementById('new-location-address').value = '';
            document.getElementById('new-location-lat').value = '';
            document.getElementById('new-location-lng').value = '';
            document.getElementById('new-location-type').value = 'dealership';
            
            // Refresh locations display
            loadLocations();
            
            // Update route builder dropdowns
            updateRouteBuilderLocations();
            
            showToast(`Location "${name}" added successfully`, 'success');
        }

        // Pre-fills the location form with existing data and switches the
                // Add button to Update mode for the given location key.
        function editLocation(key) {
            const customLocations = JSON.parse(localStorage.getItem('alm_custom_locations') || '{}');
            
            // Get location from custom storage first, then fallback to ALM_LOCATIONS
            const location = customLocations[key] || ALM_LOCATIONS[key];
            
            if (!location) {
                showToast('Location not found', 'error');
                return;
            }
            
            // Populate the form with existing data
            document.getElementById('new-location-name').value = location.name;
            document.getElementById('new-location-address').value = location.address;
            document.getElementById('new-location-type').value = location.type;
            document.getElementById('new-location-lat').value = location.lat;
            document.getElementById('new-location-lng').value = location.lng;
            
            // Change the "Add Location" button to "Update Location"
            const addBtn = document.querySelector('button[onclick="addNewLocation()"]');
            addBtn.textContent = 'Update Location';
            addBtn.onclick = function() { updateLocation(key); };
            
            // Show edit notice
            showEditModeNotice(location.name, key);
            
            // Scroll to form
            document.querySelector('.route-card').scrollIntoView({ behavior: 'smooth' });
            
            showToast(`Editing "${location.name}" - Update the fields and click "Update Location"`, 'warning');
        }

        // Injects an "EDITING MODE" banner above the form so the user
                // knows which location is being modified.
        function showEditModeNotice(locationName, key) {
            // Add or update edit notice
            let notice = document.getElementById('edit-mode-notice');
            if (!notice) {
                notice = document.createElement('div');
                notice.id = 'edit-mode-notice';
                notice.className = 'draft-banner show';
                notice.style.marginBottom = '15px';
                
                const form = document.querySelector('.route-form').parentElement;
                form.insertBefore(notice, form.firstChild);
            }
            
            notice.innerHTML = `
                <strong>EDITING MODE:</strong> Currently editing "${locationName}"
                <div class="draft-actions">
                    <button class="draft-btn" onclick="cancelLocationEdit()">Cancel Edit</button>
                </div>
            `;
        }

        // Saves the edited form values back to localStorage and ALM_LOCATIONS.
                // Built-in locations get a new custom key; custom ones update in place.
        function updateLocation(key) {
            const name = document.getElementById('new-location-name').value.trim();
            const address = document.getElementById('new-location-address').value.trim();
            const type = document.getElementById('new-location-type').value;
            const lat = parseFloat(document.getElementById('new-location-lat').value);
            const lng = parseFloat(document.getElementById('new-location-lng').value);
            
            // Validation
            if (!name || !address || !type) {
                showToast('Please fill in all required fields', 'warning');
                return;
            }
            
            if (isNaN(lat) || isNaN(lng)) {
                showToast('Please provide valid coordinates', 'warning');
                return;
            }
            
            if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                showToast('Coordinates are out of valid range', 'error');
                return;
            }
            
            // Get existing locations
            const customLocations = JSON.parse(localStorage.getItem('alm_custom_locations') || '{}');
            const originalLocation = customLocations[key] || ALM_LOCATIONS[key];
            const originalName = originalLocation?.name || 'Unknown';
            
            // Create/update the location
            const updatedLocation = {
                name: name,
                address: address,
                lat: lat,
                lng: lng,
                type: type
            };
            
            // If editing a built-in ALM location, create a new custom key
            let finalKey = key;
            if (ALM_LOCATIONS[key] && !key.startsWith('custom_')) {
                // Create new custom key for edited built-in location
                finalKey = 'custom_' + key + '_edited_' + Date.now();
                customLocations[finalKey] = updatedLocation;
                
                // Remove the old custom entry if it exists
                if (customLocations[key]) {
                    delete customLocations[key];
                }
            } else {
                // Editing an existing custom location
                customLocations[key] = updatedLocation;
            }
            
            // Save to localStorage
            localStorage.setItem('alm_custom_locations', JSON.stringify(customLocations));
            
            // Update runtime locations
            ALM_LOCATIONS[finalKey] = updatedLocation;
            if (finalKey !== key && !ALM_LOCATIONS.hasOwnProperty(key)) {
                // Remove old key if it was purely custom
                delete ALM_LOCATIONS[key];
            }
            
            // Exit edit mode
            cancelLocationEdit();
            
            // Refresh locations display
            loadLocations();
            
            // Update route builder dropdowns
            updateRouteBuilderLocations();
            
            showToast(`Location "${originalName}" updated to "${name}"`, 'success');
        }

        // Clears the form, resets the button back to Add Location,
                // and removes the editing mode banner.
        function cancelLocationEdit() {
            // Clear form
            document.getElementById('new-location-name').value = '';
            document.getElementById('new-location-address').value = '';
            document.getElementById('new-location-lat').value = '';
            document.getElementById('new-location-lng').value = '';
            document.getElementById('new-location-type').value = 'dealership';
            
            // Reset button
            const addBtn = document.querySelector('button[onclick*="Location"]');
            addBtn.textContent = 'Add Location';
            addBtn.onclick = function() { addNewLocation(); };
            
            // Remove edit notice
            const notice = document.getElementById('edit-mode-notice');
            if (notice) {
                notice.remove();
            }
            
            showToast('Edit cancelled', 'success');
        }

        // Confirms and then removes a custom location from localStorage
                // and ALM_LOCATIONS, then refreshes the display and dropdowns.
        function deleteCustomLocation(key) {
            if (!key.startsWith('custom_')) {
                showToast('Cannot delete built-in ALM locations', 'error');
                return;
            }
            
            const customLocations = JSON.parse(localStorage.getItem('alm_custom_locations') || '{}');
            const locationName = customLocations[key]?.name || 'Unknown';
            
            if (!confirm(`Are you sure you want to delete "${locationName}"?`)) {
                return;
            }
            
            // Remove from storage
            delete customLocations[key];
            localStorage.setItem('alm_custom_locations', JSON.stringify(customLocations));
            
            // Remove from runtime locations
            delete ALM_LOCATIONS[key];
            
            // Refresh locations display
            loadLocations();
            
            // Update route builder dropdowns
            updateRouteBuilderLocations();
            
            showToast(`Location "${locationName}" deleted`, 'success');
        }

        // Syncs all stop-select dropdowns in the route builder to the
                // current ALM_LOCATIONS (after adding, editing, or deleting a location).
        function updateRouteBuilderLocations() {
            // Update all route builder dropdown menus
            const selects = document.querySelectorAll('.stop-select');
            selects.forEach(select => {
                const currentValue = select.value;
                const options = Object.entries(ALM_LOCATIONS).map(([key, loc]) => 
                    `<option value="${key}" ${currentValue === key ? 'selected' : ''}>${loc.name}</option>`
                ).join('');
                
                select.innerHTML = `<option value="">Choose location...</option>${options}`;
            });
        }

        // ════════════════════════════════════════════════════════════════════
        //  DISTANCE MATRIX
        //  Build and render the location-to-location distance grid from cache.
        //  Cells are clickable — they jump to Spot-Check for that pair.
        // ════════════════════════════════════════════════════════════════════

        // Reads the distance cache and renders a grid table of all
                // location-to-location pairs. Every cell is clickable to open
                // Spot-Check for that specific pair.
        function loadDistanceMatrix() {
            const container = document.getElementById('distance-matrix-container');
            const cachedDistances = JSON.parse(localStorage.getItem('maps_distances_v2') || '{}');
            
            // Use all locations including custom ones
            const locations = Object.entries(ALM_LOCATIONS);
            
            let tableHTML = '<table class="data-table distance-matrix"><thead><tr><th style="min-width: 120px;"></th>';
            locations.forEach(([key, loc]) => {
                const displayName = loc.name.replace('ALM ', '').replace('Custom ', '');
                tableHTML += `<th class="location-header" style="min-width: 80px;">${displayName}</th>`;
            });
            tableHTML += '</tr></thead><tbody>';
            
            locations.forEach(([fromKey, fromLoc]) => {
                const fromDisplayName = fromLoc.name.replace('ALM ', '').replace('Custom ', '');
                tableHTML += `<tr><td class="location-header" style="min-width: 120px;">${fromDisplayName}</td>`;
                
                locations.forEach(([toKey, toLoc]) => {
                    if (fromKey === toKey) {
                        tableHTML += '<td class="distance-cell">-</td>';
                    } else {
                        const cacheKey = `${fromKey}_${toKey}`;
                        const distance = cachedDistances[cacheKey];
                        const cellContent = distance !== undefined ? `${parseFloat(distance).toFixed(1)} mi` : '—';
                        const cellClass   = distance !== undefined ? 'distance-cell clickable' : 'distance-cell unavailable clickable';
                        const cellTitle   = distance !== undefined ? `${cellContent} — click to update` : 'Not cached — click to spot-check';
                        tableHTML += `<td class="${cellClass}" title="${cellTitle}" onclick="matrixOpenSpotCheck('${fromKey}','${toKey}')">${cellContent}</td>`;
                    }
                });
                
                tableHTML += '</tr>';
            });
            
            tableHTML += '</tbody></table>';
            
            // Legend
            tableHTML += '<div style="margin-top:10px; font-size:11px; color:#666;">— = Not yet cached. Click any cell to spot-check or update that pair.</div>';
            
            container.innerHTML = tableHTML;
        }

        // Navigates to the Spot-Check page, pre-fills the start/end
                // dropdowns with the clicked pair, and auto-runs the check.
        function matrixOpenSpotCheck(fromKey, toKey) {
            // Navigate to spot-check page
            const navItem = document.querySelector('.nav-item[data-page="dist-spotcheck"]');
            if (navItem) navItem.click();

            // Pre-fill the dropdowns after the page renders
            setTimeout(() => {
                const startSel = document.getElementById('sc-start');
                const endSel   = document.getElementById('sc-end');
                if (startSel) startSel.value = fromKey;
                if (endSel)   endSel.value   = toKey;
                // Auto-run the check
                runSpotCheck();
            }, 50);
        }

        // ════════════════════════════════════════════════════════════════════
        //  CHARTS & ANALYTICS
        //  Monthly miles bar chart, purpose breakdown doughnut, and stats summary
        //  grid — all powered by Chart.js from saved route data.
        // ════════════════════════════════════════════════════════════════════

        let monthlyChart = null;
        let purposeChart = null;

        // Entry point for the Charts page — destroys any existing Chart.js
                // instances and rebuilds the monthly and purpose charts.
        function loadCharts() {
            const routes = JSON.parse(localStorage.getItem('alm_routes') || '[]');
            
            // Destroy existing charts
            if (monthlyChart) {
                monthlyChart.destroy();
            }
            if (purposeChart) {
                purposeChart.destroy();
            }
            
            createMonthlyChart(routes);
            createPurposeChart(routes);
            updateStatsGrid(routes);
        }

        // Groups routes by YYYY-MM and renders a bar chart of total miles
                // per month using Chart.js.
        function createMonthlyChart(routes) {
            const ctx = document.getElementById('monthly-chart');
            if (!ctx) return;
            
            // Group routes by month
            const monthlyData = {};
            routes.forEach(route => {
                const month = route.date.substring(0, 7); // YYYY-MM
                if (!monthlyData[month]) {
                    monthlyData[month] = 0;
                }
                monthlyData[month] += route.totalMiles || 0;
            });
            
            const sortedMonths = Object.keys(monthlyData).sort();
            const labels = sortedMonths.map(month => {
                const date = new Date(month + '-01');
                return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
            });
            const data = sortedMonths.map(month => monthlyData[month]);
            
            monthlyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Miles',
                        data: data,
                        backgroundColor: '#ffa726',
                        borderColor: '#ff9800',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: '#666'
                            },
                            grid: {
                                color: '#333'
                            }
                        },
                        x: {
                            ticks: {
                                color: '#666'
                            },
                            grid: {
                                color: '#333'
                            }
                        }
                    }
                }
            });
        }

        // Groups routes by trip purpose and renders a doughnut chart
                // of miles broken down by purpose.
        function createPurposeChart(routes) {
            const ctx = document.getElementById('purpose-chart');
            if (!ctx) return;
            
            // Group routes by purpose
            const purposeData = {};
            routes.forEach(route => {
                const purpose = route.purpose || 'Unknown';
                if (!purposeData[purpose]) {
                    purposeData[purpose] = 0;
                }
                purposeData[purpose] += route.totalMiles || 0;
            });
            
            const colors = ['#ffa726', '#22c55e', '#ef4444', '#3b82f6', '#8b5cf6', '#f59e0b'];
            const labels = Object.keys(purposeData);
            const data = Object.values(purposeData);
            
            purposeChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors.slice(0, labels.length),
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#666',
                                padding: 20
                            }
                        }
                    }
                }
            });
        }

        // Calculates aggregate stats (total trips, miles, cost, averages)
                // and renders them as stat cards on the Charts page.
        function updateStatsGrid(routes) {
            const container = document.getElementById('stats-summary');
            
            const totalRoutes = routes.length;
            const totalMiles = routes.reduce((sum, r) => sum + (r.totalMiles || 0), 0);
            const totalCost = routes.reduce((sum, r) => sum + (r.cost || 0), 0);
            const reimbursableRoutes = routes.filter(r => r.reimbursable).length;
            const avgMilesPerTrip = totalRoutes > 0 ? (totalMiles / totalRoutes) : 0;
            const syncedRoutes = routes.filter(r => r.synced).length;
            
            const statsHTML = `
                <div class="stat-card">
                    <div class="stat-value">${totalRoutes}</div>
                    <div class="stat-label">Total Trips</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${totalMiles.toFixed(1)}</div>
                    <div class="stat-label">Total Miles</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">$${totalCost.toFixed(2)}</div>
                    <div class="stat-label">Total Cost</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${reimbursableRoutes}</div>
                    <div class="stat-label">Reimbursable Trips</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${avgMilesPerTrip.toFixed(1)}</div>
                    <div class="stat-label">Avg Miles/Trip</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${syncedRoutes}</div>
                    <div class="stat-label">Synced Trips</div>
                </div>
            `;
            
            container.innerHTML = statsHTML;
        }

        // ════════════════════════════════════════════════════════════════════
        //  COST REPORT
        //  Calculate total mileage reimbursement at the IRS rate and render
        //  a monthly breakdown table.
        // ════════════════════════════════════════════════════════════════════

        // Sums total miles and reimbursement from all saved routes and
                // updates the summary cards, then builds the monthly breakdown table.
        function loadCostReport() {
            const routes = JSON.parse(localStorage.getItem('alm_routes') || '[]');
            
            // Update summary cards
            const totalMiles = routes.reduce((sum, r) => sum + (r.totalMiles || 0), 0);
            const totalReimbursement = routes.reduce((sum, r) => sum + (r.cost || 0), 0);
            
            document.getElementById('total-miles-card').textContent = totalMiles.toFixed(1);
            document.getElementById('total-reimbursement-card').textContent = '$' + totalReimbursement.toFixed(2);
            
            // Create monthly breakdown table
            createMonthlyCostTable(routes);
        }

        // Groups routes by month and renders a table with trips, miles,
                // total cost, and average cost per trip for each month.
        function createMonthlyCostTable(routes) {
            const container = document.getElementById('monthly-cost-table');
            
            // Group by month
            const monthlyData = {};
            routes.forEach(route => {
                const month = route.date.substring(0, 7);
                if (!monthlyData[month]) {
                    monthlyData[month] = {
                        trips: 0,
                        miles: 0,
                        cost: 0,
                        reimbursableTrips: 0
                    };
                }
                
                monthlyData[month].trips++;
                monthlyData[month].miles += route.totalMiles || 0;
                monthlyData[month].cost += route.cost || 0;
                if (route.reimbursable) {
                    monthlyData[month].reimbursableTrips++;
                }
            });
            
            const sortedMonths = Object.keys(monthlyData).sort().reverse();
            
            const table = document.createElement('table');
            table.className = 'data-table';
            
            table.innerHTML = `
                <thead>
                    <tr>
                        <th>Month</th>
                        <th>Total Trips</th>
                        <th>Reimbursable Trips</th>
                        <th>Total Miles</th>
                        <th>Total Cost</th>
                        <th>Avg Cost/Trip</th>
                    </tr>
                </thead>
                <tbody>
                    ${sortedMonths.map(month => {
                        const data = monthlyData[month];
                        const avgCost = data.trips > 0 ? (data.cost / data.trips) : 0;
                        const monthName = new Date(month + '-01').toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                        
                        return `
                            <tr>
                                <td>${monthName}</td>
                                <td>${data.trips}</td>
                                <td>${data.reimbursableTrips}</td>
                                <td>${data.miles.toFixed(1)}</td>
                                <td>$${data.cost.toFixed(2)}</td>
                                <td>$${avgCost.toFixed(2)}</td>
                            </tr>
                        `;
                    }).join('')}
                </tbody>
            `;
            
            container.innerHTML = '';
            container.appendChild(table);
        }

        // ════════════════════════════════════════════════════════════════════
        //  CHANGELOG
        //  Renders the full version history. Add new entries at the top of
        //  the changelog array inside loadChangelog().
        // ════════════════════════════════════════════════════════════════════

        // Defines the full version history array and renders it as a list
                // of version cards. Add new entries at the TOP of the changelog array.
        function loadChangelog() {
            const container = document.getElementById('changelog-content');
            
            const changelog = [
                {
                    version: 'v1.9.4',
                    date: 'February 2026',
                    features: [
                        'Distance Matrix cells are now clickable — click any cell in the matrix to jump directly to the Spot-Check page with that pair pre-filled and the live check auto-running. Works for both cached values and empty cells.',
                        'Spot-Check now shows all route alternatives as a picker — after fetching, all routes returned by the API appear as buttons sorted shortest first. You choose which one to save rather than always defaulting to the shortest.',
                        'Spot-Check picker saves directly to the Distance Matrix — selecting a route writes it to cache and instantly refreshes the matrix if it is currently open, with no page reload required.',
                        'Distance Refresh Save All also updates the matrix live — saving selections from the refresh picker now refreshes the matrix table on the spot if you have it open.',
                        'Version number corrected on main page — title and logo now correctly show v1.9.x instead of the old v13.x numbering.'
                    ]
                },
                {
                    version: 'v1.9.3',
                    date: 'February 2026',
                    features: [
                        'Distance Refresh now shows route picker — after fetching alternatives, all pairs are displayed as interactive cards below the terminal. You choose your preferred route for each pair, then click Save All Selections to write them to cache in one action. Nothing is saved automatically.',
                        'Refresh picker counter — a status bar above the cards tracks how many pairs have been fetched, how many selections you have made, and how many remain. The Save button is locked until every pair has a selection.',
                        'Dead code removed — getSingleLegDistance, getDistanceMatrix, cacheOptimizedDistances, getOptimizedDirections, updateDistanceDisplayFromDirections, and updateDistanceDisplay were all unreachable and have been deleted.',
                        'Map preview traffic model removed — displayRouteOnMap no longer passes drivingOptions or trafficModel to the Directions API, consistent with the no-traffic policy applied everywhere else.',
                        'Month filter now dynamic — the Trip History month dropdown is populated from actual saved route dates instead of a hardcoded list of 2026 months. Works for any year and updates automatically as new routes are added.'
                    ]
                },
                {
                    version: 'v1.9.2',
                    date: 'February 2026',
                    features: [
                        'Distance Refresh overhauled — now uses Directions API (one call per pair) instead of Distance Matrix batch calls, eliminating the N×N grid cross-matching bug that caused wrong distances to be stored under wrong route pairs.',
                        'Distance Spot-Check overhauled — switched from Distance Matrix API to Directions API with route alternatives, so spot-check results now exactly match what the route builder\'s picker shows.',
                        'Spot-Check "Use Live Value" button — when a mismatch or missing cache entry is found, a one-click button lets you push the live API result directly into cache without running a full refresh.',
                        'Refresh "Used Routes" no longer mirrors pairs — previously A→B would auto-add B→A to the cache as the same value. Now only the direction actually traveled is cached, since road distances are not always equal in both directions.',
                        'Refresh pair count is now dynamic — the "Refresh All Pairs" button shows the real computed count based on actual locations in the app, not a hardcoded number.',
                        'Distance Matrix display no longer shows haversine estimates — cells with no cached value now show "—" with a tooltip directing you to run a Distance Refresh, instead of a fake estimated number marked with an asterisk.',
                        'Directions API in Refresh shows route count — each terminal log line now shows how many route alternatives were checked and confirms the shortest was picked.',
                        'rebuildStopsList now clears route pickers — resuming a draft no longer leaves stale picker elements on screen from a previous session.'
                    ]
                },
                {
                    version: 'v1.9.1',
                    date: 'February 2026',
                    features: [
                        'Route picker UI — when a leg has no cached distance, up to 3 route alternatives appear inline below the stop, sorted shortest to longest. You click the one that matches how you actually drive and it locks in. If only one route is available, a single "Confirm" button appears with a note.',
                        'Distances are now directional — A→B and B→A are stored as separate cache entries since road distances are not always equal in both directions.',
                        'Haversine fallback removed from all route calculation paths — if a leg cannot be fetched, the badge shows "N/A" in red rather than a fabricated estimate.',
                        'Traffic completely removed from all API calls — drivingOptions block eliminated across all Directions API requests. All distances now reflect pure road distance with no time-of-day or traffic-model bias.',
                        'Distance Matrix multi-leg bug fixed — previously getDistanceMatrix sent all stops as an N×N grid and only read rows[0], silently zeroing every leg beyond the first. Rewritten to call the API once per leg sequentially.',
                        'Route builder\'s Distance Matrix fallback removed — the route builder now goes exclusively through the picker system and cache; the legacy getDistanceMatrix path is no longer triggered.',
                        'Cache is populated on pick — selecting a route option writes it to localStorage immediately so future visits to the same pair load instantly without an API call.'
                    ]
                },
                {
                    version: 'v1.9.0',
                    date: 'February 2026',
                    features: [
                        'Distance Refresh page added to the APP section — a terminal-style CLI interface for bulk refreshing cached distances. Shows timestamps, step-by-step progress, individual pair results, and a blinking cursor.',
                        'Three refresh modes available — Refresh All Pairs fetches every directional combination across all locations, Refresh Used Routes Only fetches pairs from saved trip history, and Clear Cache Only wipes the cache without making API calls.',
                        'Status bar on Refresh page — shows last sync timestamp, total cache entries, Maps API connection state, and an overall health indicator color-coded green/amber/red.',
                        'Distance Spot-Check page added — lets you test a single location pair without running a bulk refresh. Shows cached distance, live API distance, difference in miles and percentage, and a MATCH / MISMATCH / NO CACHE badge.',
                        'Spot-Check running log — keeps a timestamped history of all checks run in the current session, up to 20 entries.',
                        'Sidebar reorganized — Refresh Distances removed from the DATA section; Distance Refresh and Distance Spot-Check added to the APP section alongside Changelog.'
                    ]
                },
                {
                    version: 'v1.8.0',
                    date: 'February 2026',
                    features: [
                        'Universal location editing — all locations can now be edited, including built-in ALM dealerships and the corporate office, not just custom-added locations.',
                        'Improved Distance Matrix readability — fixed dark header cell background colors that made column and row labels unreadable.',
                        'Edit form pre-fills with existing data — clicking Edit on any location populates the form with its current name, address, coordinates, and type.',
                        'Built-in vs custom edit handling — built-in locations edited in-place in memory, custom locations updated in localStorage, both reflected immediately across all dropdowns and the distance matrix.'
                    ]
                },
                {
                    version: 'v1.7.2',
                    date: 'February 2026',
                    features: [
                        'Updated map markers to AdvancedMarkerElement API — replaces deprecated google.maps.Marker to eliminate deprecation warnings in the browser console.',
                        'Graceful fallback — app continues working with legacy markers if the new AdvancedMarkerElement API is unavailable in the loaded Maps JS version.',
                        'Custom marker shapes preserved — H marker for Home, C marker for Corporate, numbered markers for ALM locations, all retained with the new API.'
                    ]
                },
                {
                    version: 'v1.7.1',
                    date: 'February 2026',
                    features: [
                        'Improved Google Maps API error handling — app no longer silently fails when an API is missing; errors surface with descriptive messages.',
                        'Geocoding API made optional — address lookup works when the Geocoding API is enabled, and degrades gracefully with a clear message when it is not.',
                        'Console logging for API troubleshooting — startup checks log which APIs are available, making it easier to diagnose missing API activations in Google Cloud Console.',
                        'Maps API status detection improved — the status pill in the header more accurately reflects whether Maps is actually functional, not just loaded.'
                    ]
                },
                {
                    version: 'v1.7.0',
                    date: 'February 2026',
                    features: [
                        'Print-friendly views — professional black and white print stylesheets added for expense reports and trip history.',
                        'Print buttons on Trip History and Cost Report pages — Print Current View prints the active page, Print Filtered Data only works when filters are applied.',
                        'Add new locations — custom location form on the Locations page lets you add any address with name, type, and coordinates. Geocoding support auto-fills coordinates from a street address.',
                        'Custom locations appear everywhere immediately — route builder dropdowns, distance matrix, and spot-check all update as soon as a new location is saved.',
                        'Delete custom locations — remove any custom-added location with a confirmation prompt.',
                        'Fixed Distance Matrix horizontal scrolling — overflow now works correctly on mobile and portrait orientations with a sticky first column.',
                        'Complete changelog added — all versions v1.0.0 through current documented in the Changelog page.'
                    ]
                },
                {
                    version: 'v1.6.0',
                    date: 'February 2026',
                    features: [
                        'Smart import conflict detection — when importing an Excel file, the app identifies routes that share the same date and total miles as existing saved routes.',
                        'Conflict resolution modal — side-by-side comparison of existing vs incoming data with three options per conflict: Overwrite (replace existing), Skip (keep existing), or Keep Both (import with an adjusted date).',
                        'Date adjustment logic — Keep Both mode suggests the next available date that does not already have a conflicting entry.',
                        'Bulk resolution actions — Skip All and Overwrite All buttons for handling many conflicts at once.',
                        'Conflicts remaining counter — live count in the modal shows how many conflicts still need a decision before import can proceed.'
                    ]
                },
                {
                    version: 'v1.5.0',
                    date: 'February 2026',
                    features: [
                        'Map preview — Google Maps integration renders a visual route preview with an amber polyline connecting all stops.',
                        'Custom map markers — Home location marked with H, Corporate with C, ALM dealerships with sequential numbers.',
                        'Route visualization toggle — map section is hidden by default and can be shown or hidden with a button, keeping the UI clean.',
                        'Waypoint optimization — multi-stop routes use Google\'s optimizeWaypoints to find the best stop order.',
                        'Mobile responsive map — map container scales correctly on all screen sizes.'
                    ]
                },
                {
                    version: 'v1.4.0',
                    date: 'February 2026',
                    features: [
                        'Complete dashboard — all navigation tabs functional with page-specific initialization.',
                        'Trip history — full table of saved routes with filtering by month, purpose, and reimbursable status. Delete individual routes.',
                        'Interactive charts — monthly miles bar chart and trip purpose breakdown pie chart using Chart.js.',
                        'Cost reporting — detailed reimbursement calculations at the IRS standard rate, monthly breakdown table with totals.',
                        'Locations directory — all ALM locations listed with addresses, coordinates, and type.',
                        'Distance matrix — grid showing cached road distances between all location pairs.',
                        'Working Excel import and export — SheetJS integration generates a workbook with a Summary sheet and a Detailed Legs sheet. Import reads previously exported files.',
                        'Functional navigation — all sidebar tabs work with proper page initialization hooks.'
                    ]
                },
                {
                    version: 'v1.3.0',
                    date: 'February 2026',
                    features: [
                        'Excel import — reads previously downloaded ALM export files and merges new routes into local storage.',
                        'Smart merge — only imports routes not already present, matched by date and total miles to avoid duplicates.',
                        'Parses both Summary and Detailed Legs sheets from the workbook.',
                        'Preserves synced status from the imported file so previously synced records are not marked as unsynced.'
                    ]
                },
                {
                    version: 'v1.2.1',
                    date: 'February 2026',
                    features: [
                        'Force resync — per-row Retry button on unsynced routes in Trip History lets you push individual failed entries to Google Sheets.',
                        'Sync All Unsynced — bulk button at the top of Trip History pushes every unsynced route in one action.',
                        'Auto-retry after sign-in — OAuth re-authentication automatically reprocesses routes that failed due to expired tokens.',
                        'Improved sync error handling — failure reasons now surfaced in toast messages instead of silently swallowed.'
                    ]
                },
                {
                    version: 'v1.2.0',
                    date: 'February 2026',
                    features: [
                        'Google integration — switched from OpenRouteService to Google Maps Distance Matrix API for driving distances.',
                        'Google Sheets auto-backup via OAuth 2.0 — saved routes sync automatically to a Google Sheet with a Summary tab and a Detailed Legs tab.',
                        'Header status pills — real-time indicators show Maps API connection state and Sheets sync state.',
                        'URL encoding bug fixes in Sheets sync — special characters in location names and purposes no longer break the sync request.',
                        'Token expiry handling — app detects expired OAuth tokens and triggers a re-authentication flow before retrying.'
                    ]
                },
                {
                    version: 'v1.1.1',
                    date: 'February 2026',
                    features: [
                        'Auto-save drafts — route builder state saves automatically to localStorage on every change (date, purpose, and all stop selections), so work is not lost if you navigate away or close the tab.',
                        'Draft recovery banner — a "DRAFT FOUND" notification appears at the top of the route builder on next visit, offering to restore or discard the previous unfinished route.',
                        'Draft clears automatically on successful save — once a route is saved to history, the draft is wiped so the banner does not reappear unnecessarily.',
                        'Draft includes all route state — date, trip purpose, and the full ordered list of stops are all preserved and restored.'
                    ]
                },
                {
                    version: 'v1.1.0',
                    date: 'February 2026',
                    features: [
                        'Multi-stop route builder — replaced the original single A→B form with a dynamic stop list supporting up to 6 stops (5 legs) per day. Designed around the real workflow of visiting multiple ALM dealerships in a single outing.',
                        'Visual connector UI — green dot for the start location, amber dots for intermediate stops, red dot for the final destination.',
                        'Live leg-by-leg mileage — a distance badge appears on each stop row as soon as both ends of that leg have a location selected.',
                        'Zero-mile days supported — routes with no mileage can be saved and marked non-reimbursable (e.g., Home to Corporate only).',
                        'Add and remove stops dynamically — stops can be added mid-build up to the maximum, and removed with automatic re-indexing of all remaining stops.',
                        'Six ALM location addresses corrected — verified coordinates for Gwinnett, Roswell, Buford, Kennesaw, Newnan, and Union City via web lookup and updated in the app.',
                        'Dedicated Locations page added — lists all 10 ALM locations with their full street addresses, GPS coordinates, and location type.'
                    ]
                },
                {
                    version: 'v1.0.0',
                    date: 'February 2026',
                    features: [
                        'Initial release — single A→B trip logging with date selection, trip purpose dropdown, and a reimbursable/non-reimbursable toggle.',
                        'OpenRouteService API for driving distance calculation — free tier with email-only signup, API key stored in browser localStorage so it persists between sessions.',
                        '10 ALM locations pre-loaded — Home (Canton), ALM Corporate (Union City area), and 8 dealership locations across the Atlanta metro area.',
                        'Haversine straight-line formula with 1.25x road multiplier as fallback — used when the API is unavailable or the key has not been entered.',
                        'Distance matrix view — grid showing pairwise distances between all location combinations, with cached API values or fallback estimates.',
                        'Trip history with localStorage persistence — all saved routes survive page reloads and browser restarts.',
                        'Excel export via SheetJS — downloads a workbook with a Summary sheet listing one row per trip day.',
                        'Home to Corporate flagged as non-reimbursable automatically — these commute-equivalent trips are excluded from reimbursement calculations.',
                        'Dark theme with amber accent colors — industrial dashboard aesthetic established in v1 and maintained throughout.'
                    ]
                }
            ];
            
            const changelogHTML = changelog.map(version => `
                <div class="changelog-version">
                    <div class="changelog-header">
                        <div class="version-number">${version.version}</div>
                        <div class="version-date">${version.date}</div>
                    </div>
                    <ul class="changelog-features">
                        ${version.features.map(feature => `<li>${feature}</li>`).join('')}
                    </ul>
                </div>
            `).join('');
            
            container.innerHTML = changelogHTML;
        }

        // ════════════════════════════════════════════════════════════════════
        //  ROUTE BUILDER — AUTO-SAVE & STOP MANAGEMENT
        //  Auto-save drafts on input changes. Add, remove, and re-label stops.
        //  Keep the stop counter and Add button in sync.
        // ════════════════════════════════════════════════════════════════════

        // Attaches input/change listeners to the date and purpose fields
                // so the draft saves automatically whenever either changes.
        function setupAutoSave() {
            // Auto-save draft when inputs change
            const inputs = ['trip-date', 'trip-purpose'];
            inputs.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', saveDraft);
                    element.addEventListener('change', saveDraft);
                }
            });
        }

        // Adds a new blank middle stop to the route (up to MAX_STOPS).
                // Updates labels, counter, and saves the draft.
        function addStop() {
            if (currentRoute.length >= MAX_STOPS) {
                showToast('Maximum 6 stops allowed', 'warning');
                return;
            }

            const stopsList = document.getElementById('stops-list');
            const stopIndex = currentRoute.length;
            
            const stopItem = document.createElement('div');
            stopItem.className = 'stop-item';
            stopItem.dataset.index = stopIndex;
            
            // All added stops are middle stops initially
            const indicatorClass = 'middle';
            const labelText = `STOP ${stopIndex} - END`;
            
            stopItem.innerHTML = `
                <div class="stop-indicator ${indicatorClass}"></div>
                <div class="stop-label">${labelText}</div>
                <select class="stop-select" onchange="updateRoute(${stopIndex})">
                    <option value="">Choose location...</option>
                    ${Object.entries(ALM_LOCATIONS).map(([key, loc]) => 
                        `<option value="${key}">${loc.name}</option>`
                    ).join('')}
                </select>
                <div class="stop-distance" style="display: none;">0 mi</div>
                <button class="stop-remove" onclick="removeStop(${stopIndex})">×</button>
            `;
            
            stopsList.appendChild(stopItem);
            currentRoute.push({ location: null, distance: 0 });
            
            // Update labels to ensure the last stop is marked as END
            updateStopLabels();
            
            // Update add button and stop count
            updateStopCounter();
            updateAddStopButton();
            saveDraft();
        }

        // Recalculates how many stops and legs are filled and updates
                // the counter text inside the Add Stop button.
        function updateStopCounter() {
            const validStops = currentRoute.filter(stop => stop.location).length;
            const legs = Math.max(0, validStops - 1);
            const counterText = `${validStops} locations • ${legs} legs`;
            
            const stopCount = document.getElementById('stop-count');
            if (stopCount) {
                stopCount.textContent = counterText;
            }
            
            // Update the add button text to reflect current state
            const addBtn = document.getElementById('add-stop-btn');
            if (addBtn) {
                const totalStops = currentRoute.length;
                const currentLegs = Math.max(0, totalStops - 1);
                addBtn.innerHTML = `+ Add Stop<span id="stop-count">${totalStops} locations • ${currentLegs} legs</span>`;
            }
        }

        // Removes the stop at the given index, re-indexes all remaining
                // stops, refreshes labels, and recalculates the route.
        function removeStop(index) {
            if (index === 0) {
                showToast('Cannot remove START location', 'warning');
                return;
            }
            
            if (currentRoute.length <= 2) {
                showToast('Must have at least 2 stops', 'warning');
                return;
            }
            
            const stopItem = document.querySelector(`[data-index="${index}"]`);
            if (stopItem) {
                stopItem.remove();
            }
            
            currentRoute.splice(index, 1);
            
            // Re-index remaining stops
            const stopItems = document.querySelectorAll('.stop-item');
            stopItems.forEach((item, i) => {
                item.dataset.index = i;
                const select = item.querySelector('select');
                const removeBtn = item.querySelector('.stop-remove');
                
                // Update onchange and onclick attributes
                select.setAttribute('onchange', `updateRoute(${i})`);
                if (removeBtn && i > 0) {
                    removeBtn.setAttribute('onclick', `removeStop(${i})`);
                }
            });
            
            // Update all labels and indicators
            updateStopLabels();
            updateStopCounter();
            updateAddStopButton();
            calculateOptimalRoute();
            saveDraft();
        }

        // Called when a stop's dropdown changes. Saves the selected location
                // key, refreshes labels/counter, and triggers route recalculation.
        function updateRoute(index) {
            const stopItem = document.querySelector(`[data-index="${index}"]`);
            const select = stopItem.querySelector('select');
            const locationKey = select.value;
            
            if (locationKey && ALM_LOCATIONS[locationKey]) {
                currentRoute[index].location = locationKey;
                
                // Update labels and indicators
                updateStopLabels();
                updateStopCounter();
                calculateOptimalRoute();
                saveDraft();
            }
        }

        // Walks all stop rows and sets the correct label and dot color:
                // START (green), middle STOP N (amber), END (red).
        function updateStopLabels() {
            const stopItems = document.querySelectorAll('.stop-item');
            stopItems.forEach((item, i) => {
                const label = item.querySelector('.stop-label');
                const indicator = item.querySelector('.stop-indicator');
                
                if (i === 0) {
                    // First stop is always START
                    indicator.className = 'stop-indicator start';
                    label.textContent = 'START';
                } else if (i === currentRoute.length - 1) {
                    // Last stop is always END
                    indicator.className = 'stop-indicator end';
                    label.textContent = `STOP ${i} - END`;
                } else {
                    // Middle stops
                    indicator.className = 'stop-indicator middle';
                    label.textContent = `STOP ${i}`;
                }
            });
        }

        // Hides the Add Stop button when the route is already at MAX_STOPS.
        function updateAddStopButton() {
            const addBtn = document.getElementById('add-stop-btn');
            addBtn.style.display = currentRoute.length >= MAX_STOPS ? 'none' : 'inline-flex';
        }

        // ════════════════════════════════════════════════════════════════════
        //  ROUTE CALCULATION & LEG PICKER
        //  For each leg: check cache first. If uncached, call Directions API
        //  with alternatives and show a picker. User selects distance,
        //  it writes to cache and locks in the leg total.
        // ════════════════════════════════════════════════════════════════════

        let routingPreference = 'shortest';

        // ── Route Picker System ───────────────────────────────────────────
        // For each leg, if the pair is cached use it immediately.
        // If not cached, call the Directions API with alternatives and show
        // the user a picker so they choose which route distance to lock in.

        // Processes every leg in the current route. Cache hits show the
                // distance immediately; misses trigger showLegPicker() for that leg.
        async function calculateOptimalRoute() {
            const validStops = currentRoute.filter(stop => stop.location);
            if (validStops.length < 2) {
                resetDistanceDisplay();
                clearAllRoutePickers();
                return;
            }

            // Process each leg independently
            resetDistanceDisplay();
            clearAllRoutePickers();

            let grandTotal = 0;
            let allResolved = true;

            for (let i = 0; i < validStops.length - 1; i++) {
                const fromKey = validStops[i].location;
                const toKey   = validStops[i + 1].location;
                const cacheKey = `${fromKey}_${toKey}`;
                const cache = JSON.parse(localStorage.getItem('maps_distances_v2') || '{}');

                if (cache[cacheKey] !== undefined) {
                    // Cache hit — show immediately, no picker needed
                    const miles = cache[cacheKey];
                    grandTotal += miles;
                    showLegDistance(i + 1, miles);
                } else {
                    // Not cached — fetch alternatives and show picker
                    allResolved = false;
                    showLegPicker(i, validStops, fromKey, toKey);
                }
            }

            if (allResolved) {
                commitTotalDistance(grandTotal);
            }
            // If any leg needed a picker, commitTotalDistance is called
            // by pickRoute() once all legs resolve
        }

        // Removes all inline route picker elements from the DOM — called
                // before each recalculation to avoid stale pickers accumulating.
        function clearAllRoutePickers() {
            document.querySelectorAll('.route-picker').forEach(el => el.remove());
        }

        // Updates the distance badge on the stop row at stopIndex
                // to show the confirmed miles for that leg.
        function showLegDistance(stopIndex, miles) {
            const stopItem = document.querySelector(`[data-index="${stopIndex}"]`);
            if (!stopItem) return;
            const badge = stopItem.querySelector('.stop-distance');
            badge.textContent = `${miles} mi`;
            badge.style.display  = 'block';
            badge.style.background = '';
        }

        // Checks that every leg has a cached value, sums them, and updates
                // the Day Total display. Does nothing if any leg is still unresolved.
        function commitTotalDistance(miles) {
            // Only commit if ALL legs have a selected distance
            const validStops = currentRoute.filter(s => s.location);
            const cache = JSON.parse(localStorage.getItem('maps_distances_v2') || '{}');

            let total = 0;
            let complete = true;
            for (let i = 0; i < validStops.length - 1; i++) {
                const key = `${validStops[i].location}_${validStops[i+1].location}`;
                if (cache[key] === undefined) { complete = false; break; }
                total += cache[key];
            }

            if (!complete) return; // still waiting on picker selections

            totalDistance = total;
            document.getElementById('total-value').innerHTML =
                `${total.toFixed(1)}<span class="total-unit">miles</span>`;
            document.getElementById('day-total').style.display = 'block';
            document.getElementById('total-miles-display').textContent = total.toFixed(1);
            updateMapsStatus('connected');
            updateButtons();
        }

        // Inserts a route picker card below the destination stop for this leg.
                // Fetches Directions API alternatives and renders one button per route,
                // sorted shortest first.
        async function showLegPicker(legIndex, validStops, fromKey, toKey) {
            // Insert a loading picker below this stop item
            const stopIndex = legIndex + 1; // data-index of the destination stop
            const anchorItem = document.querySelector(`[data-index="${stopIndex}"]`);
            if (!anchorItem) return;

            const pickerId = `picker-${legIndex}`;
            // Remove any existing picker for this leg
            const existing = document.getElementById(pickerId);
            if (existing) existing.remove();

            const pickerEl = document.createElement('div');
            pickerEl.className = 'route-picker';
            pickerEl.id = pickerId;
            pickerEl.innerHTML = `
                <div class="route-picker-label">
                    ${ALM_LOCATIONS[fromKey].name} → ${ALM_LOCATIONS[toKey].name} — Choose route
                </div>
                <div class="route-picker-options">
                    <span class="route-picker-loading">⟳ Fetching routes…</span>
                </div>
            `;
            anchorItem.insertAdjacentElement('afterend', pickerEl);

            // Fetch alternatives from Directions API — no traffic, distance only
            if (typeof google === 'undefined' || !directionsService) {
                pickerEl.querySelector('.route-picker-options').innerHTML =
                    '<span class="route-picker-single" style="color:#ef4444;">Maps API unavailable</span>';
                return;
            }

            const fromLoc = ALM_LOCATIONS[fromKey];
            const toLoc   = ALM_LOCATIONS[toKey];

            try {
                const result = await new Promise((resolve, reject) => {
                    directionsService.route({
                        origin:      new google.maps.LatLng(fromLoc.lat, fromLoc.lng),
                        destination: new google.maps.LatLng(toLoc.lat,   toLoc.lng),
                        travelMode:  google.maps.TravelMode.DRIVING,
                        avoidHighways: false,
                        avoidTolls:    false,
                        region: 'US',
                        provideRouteAlternatives: true
                        // No drivingOptions — pure road distance, no traffic
                    }, (res, status) => status === 'OK' ? resolve(res) : reject(new Error(status)));
                });

                const routes = result.routes;
                const optionsContainer = pickerEl.querySelector('.route-picker-options');

                if (routes.length === 1) {
                    // Only one route available
                    const miles = parseFloat((routes[0].legs[0].distance.value * 0.000621371).toFixed(2));
                    optionsContainer.innerHTML = `
                        <span class="route-picker-single">Only 1 route available — </span>
                        <button class="route-option-btn" onclick="pickRoute('${fromKey}','${toKey}',${miles},'${pickerId}',this)">
                            <span class="route-option-miles">${miles} mi</span>
                            <span class="route-option-sub">Confirm</span>
                        </button>
                    `;
                } else {
                    // Sort by distance ascending so Route 1 is always shortest
                    const sorted = [...routes].sort((a, b) =>
                        a.legs[0].distance.value - b.legs[0].distance.value
                    );
                    optionsContainer.innerHTML = sorted.map((route, idx) => {
                        const miles = parseFloat((route.legs[0].distance.value * 0.000621371).toFixed(2));
                        return `
                            <button class="route-option-btn"
                                onclick="pickRoute('${fromKey}','${toKey}',${miles},'${pickerId}',this)">
                                <span class="route-option-miles">${miles} mi</span>
                                <span class="route-option-sub">Route ${idx + 1}</span>
                            </button>
                        `;
                    }).join('');
                }

            } catch (err) {
                pickerEl.querySelector('.route-picker-options').innerHTML =
                    `<span class="route-picker-single" style="color:#ef4444;">Error: ${err.message}</span>`;
            }
        }

        // Called when the user clicks a route option button. Writes the chosen
                // distance to cache, updates the leg badge, and tries to commit the total.
        function pickRoute(fromKey, toKey, miles, pickerId, btn) {
            // Mark selected
            const picker = document.getElementById(pickerId);
            if (picker) {
                picker.querySelectorAll('.route-option-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
            }

            // Write to cache — A→B only, B→A gets its own picker when traveled
            const cache = JSON.parse(localStorage.getItem('maps_distances_v2') || '{}');
            cache[`${fromKey}_${toKey}`] = miles;
            localStorage.setItem('maps_distances_v2', JSON.stringify(cache));

            // Update the leg badge
            const validStops = currentRoute.filter(s => s.location);
            const legIndex = validStops.findIndex(s => s.location === fromKey);
            if (legIndex !== -1) showLegDistance(legIndex + 1, miles);

            // Try to commit total — will only fire if all legs now have values
            commitTotalDistance(0);

            // Collapse picker after short delay so user sees their selection
            setTimeout(() => {
                if (picker) picker.remove();
            }, 800);
        }



        // Zeroes out totalDistance, hides the Day Total panel and all leg
                // badges, and disables the Preview and Save buttons.
        function resetDistanceDisplay() {
            totalDistance = 0;
            document.getElementById('day-total').style.display = 'none';
            document.getElementById('total-miles-display').textContent = '0.0';
            
            // Hide leg badges
            document.querySelectorAll('.stop-distance').forEach(badge => {
                badge.style.display = 'none';
            });
            
            updateButtons();
        }

        // Enables or disables the Preview Route and Save Route buttons based
                // on whether there are at least 2 stops and a non-zero total distance.
        function updateButtons() {
            const previewBtn = document.getElementById('preview-btn');
            const saveBtn = document.getElementById('save-btn');
            const hasValidRoute = currentRoute.filter(s => s.location).length >= 2;
            
            previewBtn.disabled = !hasValidRoute || totalDistance === 0;
            saveBtn.disabled = !hasValidRoute || totalDistance === 0;
        }

        // ════════════════════════════════════════════════════════════════════
        //  GOOGLE MAPS INTEGRATION
        //  Initialize the Maps JS client, render route previews, draw custom
        //  SVG markers (H=Home, C=Corporate, 1-N=dealerships).
        // ════════════════════════════════════════════════════════════════════

        // Google Maps JS API callback. Initializes the Map, DirectionsService,
                // and DirectionsRenderer. Updates the Maps status pill on success/failure.
        function initMap() {
            try {
                isMapInitialized = true;
                
                // Check if Google Maps is properly loaded
                if (typeof google === 'undefined' || !google.maps) {
                    throw new Error('Google Maps JavaScript API not loaded');
                }
                
                // Initialize map (hidden by default)
                map = new google.maps.Map(document.createElement('div'), {
                    zoom: 10,
                    center: { lat: 33.9490, lng: -84.3880 }, // Atlanta center
                    styles: [
                        {
                            "elementType": "geometry",
                            "stylers": [{"color": "#1d2c4d"}]
                        },
                        {
                            "elementType": "labels.text.fill",
                            "stylers": [{"color": "#8ec3b9"}]
                        },
                        {
                            "elementType": "labels.text.stroke",
                            "stylers": [{"color": "#1a3646"}]
                        }
                        // Add more dark theme styles here...
                    ]
                });

                directionsService = new google.maps.DirectionsService();
                directionsRenderer = new google.maps.DirectionsRenderer({
                    map: map,
                    polylineOptions: {
                        strokeColor: '#ffa726',
                        strokeOpacity: 1.0,
                        strokeWeight: 4
                    }
                });

                updateMapsStatus('connected');
                console.log('Google Maps initialized successfully');
                
            } catch (error) {
                console.error('Maps initialization error:', error);
                isMapInitialized = false;
                updateMapsStatus('disconnected');
                showToast('Maps initialization failed: ' + error.message, 'error');
            }
        }

        // Shows the map container, mounts the map div, and calls
                // displayRouteOnMap() to draw the current route on screen.
        function previewRoute() {
            const validStops = currentRoute.filter(stop => stop.location);
            
            if (validStops.length < 2) {
                showToast('Need at least 2 stops to preview route', 'warning');
                return;
            }

            if (!isMapInitialized) {
                showToast('Map is still loading, please wait...', 'warning');
                return;
            }

            // Show map preview section
            const mapSection = document.getElementById('map-preview');
            const mapContainer = document.getElementById('map-container');
            
            mapSection.style.display = 'block';
            
            // Replace placeholder with actual map
            mapContainer.innerHTML = '';
            map.getDiv().style.width = '100%';
            map.getDiv().style.height = '100%';
            mapContainer.appendChild(map.getDiv());
            
            // Trigger map resize
            setTimeout(() => {
                google.maps.event.trigger(map, 'resize');
                displayRouteOnMap(validStops);
            }, 100);
            
            // Update toggle button
            document.getElementById('map-toggle-btn').textContent = 'Hide Map';
        }

        // Sends a Directions request for the full route (with waypoints) and
                // hands the result to directionsRenderer. No traffic, distance only.
        function displayRouteOnMap(stops) {
            const waypoints = stops.slice(1, -1).map(stop => {
                const loc = ALM_LOCATIONS[stop.location];
                return {
                    location: new google.maps.LatLng(loc.lat, loc.lng),
                    stopover: true
                };
            });

            const start = ALM_LOCATIONS[stops[0].location];
            const end = ALM_LOCATIONS[stops[stops.length - 1].location];

            const request = {
                origin: new google.maps.LatLng(start.lat, start.lng),
                destination: new google.maps.LatLng(end.lat, end.lng),
                waypoints: waypoints,
                travelMode: google.maps.TravelMode.DRIVING,
                optimizeWaypoints: true,
                avoidHighways: false,
                avoidTolls: false,
                region: 'US',
                provideRouteAlternatives: false
                // No drivingOptions — pure road distance, no traffic
            };

            directionsService.route(request, (result, status) => {
                if (status === 'OK') {
                    directionsRenderer.setDirections(result);
                    addCustomMarkers(stops);
                } else {
                    console.error('Directions request failed:', status);
                    showToast('Failed to load route preview', 'error');
                }
            });
        }

        // Places SVG markers on the map for each stop: H (green) for Home,
                // C (red) for Corporate, numbered amber circles for dealerships.
                // Uses AdvancedMarkerElement with a fallback to legacy Marker.
        function addCustomMarkers(stops) {
            stops.forEach((stop, index) => {
                const location = ALM_LOCATIONS[stop.location];
                const isHome = location.type === 'home';
                const isCorporate = location.type === 'corporate';
                
                // Create SVG content for the marker
                const markerContent = document.createElement('div');
                markerContent.innerHTML = `
                    <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="16" cy="16" r="14" fill="${isHome ? '#22c55e' : isCorporate ? '#ef4444' : '#ffa726'}" stroke="white" stroke-width="2"/>
                        <text x="16" y="20" text-anchor="middle" fill="white" font-family="Arial" font-size="12" font-weight="bold">
                            ${isHome ? 'H' : isCorporate ? 'C' : (index + 1)}
                        </text>
                    </svg>
                `;
                
                try {
                    // Use new AdvancedMarkerElement if available
                    if (google.maps.marker && google.maps.marker.AdvancedMarkerElement) {
                        const marker = new google.maps.marker.AdvancedMarkerElement({
                            position: { lat: location.lat, lng: location.lng },
                            map: map,
                            title: location.name,
                            content: markerContent
                        });
                    } else {
                        // Fallback to legacy Marker if AdvancedMarkerElement not available
                        const marker = new google.maps.Marker({
                            position: { lat: location.lat, lng: location.lng },
                            map: map,
                            title: location.name,
                            icon: {
                                url: `data:image/svg+xml,${encodeURIComponent(`
                                    <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                                        <circle cx="16" cy="16" r="14" fill="${isHome ? '#22c55e' : isCorporate ? '#ef4444' : '#ffa726'}" stroke="white" stroke-width="2"/>
                                        <text x="16" y="20" text-anchor="middle" fill="white" font-family="Arial" font-size="12" font-weight="bold">
                                            ${isHome ? 'H' : isCorporate ? 'C' : (index + 1)}
                                        </text>
                                    </svg>
                                `)}`,
                                scaledSize: new google.maps.Size(32, 32)
                            }
                        });
                    }
                } catch (error) {
                    console.warn('Error creating advanced marker, falling back to legacy marker:', error);
                    // Fallback to legacy marker on error
                    const marker = new google.maps.Marker({
                        position: { lat: location.lat, lng: location.lng },
                        map: map,
                        title: location.name,
                        icon: {
                            url: `data:image/svg+xml,${encodeURIComponent(`
                                <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                                    <circle cx="16" cy="16" r="14" fill="${isHome ? '#22c55e' : isCorporate ? '#ef4444' : '#ffa726'}" stroke="white" stroke-width="2"/>
                                    <text x="16" y="20" text-anchor="middle" fill="white" font-family="Arial" font-size="12" font-weight="bold">
                                        ${isHome ? 'H' : isCorporate ? 'C' : (index + 1)}
                                    </text>
                                </svg>
                            `)}`,
                            scaledSize: new google.maps.Size(32, 32)
                        }
                    });
                }
            });
        }

        // If the map is hidden, calls previewRoute() to show it.
                // If visible, hides it and resets the toggle button label.
        function toggleMapPreview() {
            const mapSection = document.getElementById('map-preview');
            const toggleBtn = document.getElementById('map-toggle-btn');
            
            if (mapSection.style.display === 'none' || !mapSection.style.display) {
                previewRoute();
            } else {
                mapSection.style.display = 'none';
                toggleBtn.textContent = 'Show Map';
            }
        }

        // ════════════════════════════════════════════════════════════════════
        //  ROUTE SAVE, DRAFT & STATUS
        //  Save completed routes to localStorage, manage the auto-draft
        //  (resume/discard), and update the header status pills.
        // ════════════════════════════════════════════════════════════════════

        // Resets currentRoute, clears the stops list and pickers, hides the
                // map, and re-initializes the default two-stop layout.
        function clearRoute() {
            currentRoute = [];
            document.getElementById('stops-list').innerHTML = '';
            clearAllRoutePickers();
            resetDistanceDisplay();
            
            // Hide map preview
            document.getElementById('map-preview').style.display = 'none';
            
            // Reset form
            document.getElementById('trip-purpose').value = '';
            
            // Initialize with default 3-stop route
            initializeDefaultRoute();
            
            clearDraft();
        }

        // Validates the form, builds a route data object, appends it to
                // localStorage, then clears the form and draft.
        function saveRoute() {
            const date = document.getElementById('trip-date').value;
            const purpose = document.getElementById('trip-purpose').value;
            const validStops = currentRoute.filter(stop => stop.location);
            
            if (!date || !purpose || validStops.length < 2 || totalDistance === 0) {
                showToast('Please complete all fields and calculate route', 'warning');
                return;
            }
            
            // Check for non-reimbursable routes
            const isNonReimbursable = checkNonReimbursable(validStops);
            
            const routeData = {
                id: Date.now().toString(),
                date: date,
                purpose: purpose,
                stops: validStops.map(stop => ({
                    location: stop.location,
                    name: ALM_LOCATIONS[stop.location].name
                })),
                totalMiles: totalDistance,
                reimbursable: !isNonReimbursable,
                cost: isNonReimbursable ? 0 : (totalDistance * IRS_RATE),
                timestamp: new Date().toISOString(),
                synced: false
            };
            
            // Save to localStorage
            const existingRoutes = JSON.parse(localStorage.getItem('alm_routes') || '[]');
            existingRoutes.push(routeData);
            localStorage.setItem('alm_routes', JSON.stringify(existingRoutes));
            
            // Clear form and draft
            clearRoute();
            clearDraft();
            
            showToast(`Trip saved successfully! ${isNonReimbursable ? '(Non-reimbursable)' : ''}`, 'success');
        }

        // Returns true if the route is a direct Home ↔ Corporate commute,
                // which is excluded from mileage reimbursement.
        function checkNonReimbursable(stops) {
            // Home <-> Corporate is non-reimbursable
            if (stops.length === 2) {
                const [start, end] = stops;
                return (start.location === 'home' && end.location === 'corporate') ||
                       (start.location === 'corporate' && end.location === 'home');
            }
            return false;
        }

        // Draft Management
        // Serializes the current date, purpose, and stop selections to
                // localStorage so work is not lost if the user navigates away.
        function saveDraft() {
            const draftData = {
                date: document.getElementById('trip-date').value,
                purpose: document.getElementById('trip-purpose').value,
                route: currentRoute,
                timestamp: new Date().toISOString()
            };
            
            localStorage.setItem('alm_draft_route', JSON.stringify(draftData));
        }

        // On startup, checks if a draft exists and shows the resume banner
                // if one is found.
        function checkDraft() {
            const draft = localStorage.getItem('alm_draft_route');
            if (draft) {
                const draftData = JSON.parse(draft);
                document.getElementById('draft-banner').classList.add('show');
            }
        }

        // Restores date, purpose, and stop selections from the saved draft,
                // then recalculates the route.
        function resumeDraft() {
            const draft = localStorage.getItem('alm_draft_route');
            if (draft) {
                const draftData = JSON.parse(draft);
                
                // Restore form data
                document.getElementById('trip-date').value = draftData.date || '';
                document.getElementById('trip-purpose').value = draftData.purpose || '';
                
                // Restore route
                if (draftData.route && draftData.route.length > 0) {
                    currentRoute = draftData.route;
                    rebuildStopsList();
                    calculateOptimalRoute();
                }
                
                document.getElementById('draft-banner').classList.remove('show');
                showToast('Draft restored successfully', 'success');
            }
        }

        // Deletes the draft from localStorage and hides the resume banner.
        function discardDraft() {
            clearDraft();
            document.getElementById('draft-banner').classList.remove('show');
            showToast('Draft discarded', 'warning');
        }

        // Low-level: removes the draft key from localStorage.
        function clearDraft() {
            localStorage.removeItem('alm_draft_route');
        }

        // Reconstructs the stop rows from the currentRoute array — used
                // after resuming a draft to restore the full UI state.
        function rebuildStopsList() {
            const stopsList = document.getElementById('stops-list');
            stopsList.innerHTML = '';
            
            currentRoute.forEach((stop, index) => {
                const stopItem = document.createElement('div');
                stopItem.className = 'stop-item';
                stopItem.dataset.index = index;
                
                let indicatorClass, labelText;
                if (index === 0) {
                    indicatorClass = 'start';
                    labelText = 'START';
                } else if (index === currentRoute.length - 1) {
                    indicatorClass = 'end';
                    labelText = `STOP ${index} - END`;
                } else {
                    indicatorClass = 'middle';
                    labelText = `STOP ${index}`;
                }
                
                stopItem.innerHTML = `
                    <div class="stop-indicator ${indicatorClass}"></div>
                    <div class="stop-label">${labelText}</div>
                    <select class="stop-select" onchange="updateRoute(${index})">
                        <option value="">Choose location...</option>
                        ${Object.entries(ALM_LOCATIONS).map(([key, loc]) => 
                            `<option value="${key}" ${stop.location === key ? 'selected' : ''}>${loc.name}</option>`
                        ).join('')}
                    </select>
                    <div class="stop-distance" style="display: none;">0 mi</div>
                    ${index > 0 ? `<button class="stop-remove" onclick="removeStop(${index})">×</button>` : ''}
                `;
                
                stopsList.appendChild(stopItem);
            });
            
            updateStopCounter();
            updateAddStopButton();
        }

        // Status Management
        // Checks Maps API availability and updates both status pills in the
                // header (Maps and Sheets).
        function updateStatus() {
            updateMapsStatus('checking');
            updateSheetsStatus('checking');
            
            // Check Maps API
            if (typeof google !== 'undefined' && google.maps) {
                updateMapsStatus('connected');
            } else {
                setTimeout(() => {
                    if (typeof google !== 'undefined' && google.maps) {
                        updateMapsStatus('connected');
                    } else {
                        updateMapsStatus('disconnected');
                    }
                }, 3000);
            }
            
            // Check Sheets (placeholder for now)
            setTimeout(() => {
                updateSheetsStatus('disconnected');
            }, 1000);
        }

        // Sets the Maps status pill to green (MAPS ACTIVE) or red (MAPS ERROR).
        function updateMapsStatus(status) {
            const pill = document.getElementById('maps-status');
            if (status === 'connected') {
                pill.className = 'status-pill maps-active';
                pill.innerHTML = '● MAPS ACTIVE';
            } else {
                pill.className = 'status-pill sheets-signin'; // red color
                pill.innerHTML = '● MAPS ERROR';
            }
        }

        // Sets the Sheets status pill to green (connected) or red (sign in).
        function updateSheetsStatus(status) {
            const pill = document.getElementById('sheets-status');
            if (status === 'connected') {
                pill.className = 'status-pill maps-active'; // green color
                pill.innerHTML = '● SHEETS CONNECTED';
            } else {
                pill.className = 'status-pill sheets-signin';
                pill.innerHTML = '● SHEETS: SIGN IN';
            }
        }

        // ════════════════════════════════════════════════════════════════════
        //  DISTANCE REFRESH
        //  Bulk-fetch driving distances for all pairs (or used-only) via the
        //  Directions API. Results shown as a route picker — user selects
        //  preferred route per pair, then saves all at once.
        // ════════════════════════════════════════════════════════════════════

        let drRunning = false;

        // Called when the Distance Refresh page becomes active. Refreshes
                // the status bar and updates the dynamic pair count on the button.
        function initDistRefreshPage() {
            updateDrStatusBar();
            // Dynamic pair count: N locations × (N-1) directions
            const n = Object.keys(ALM_LOCATIONS).length;
            const el = document.getElementById('dr-pair-count');
            if (el) el.textContent = n * (n - 1);
        }

        // Reads cache and sync metadata from localStorage and updates all
                // four status bar values (Last Sync, Cache Entries, API, Health).
        function updateDrStatusBar() {
            const cache = JSON.parse(localStorage.getItem('maps_distances_v2') || '{}');
            const count = Object.keys(cache).length;
            const lastSync = localStorage.getItem('alm_last_distance_sync');
            const apiOk = typeof google !== 'undefined' && google.maps;

            document.getElementById('dr-cache-count').textContent = count > 0 ? count + ' pairs' : 'Empty';
            document.getElementById('dr-cache-count').className = 'sync-status-value ' + (count > 0 ? 'good' : 'warn');

            if (lastSync) {
                const d = new Date(lastSync);
                document.getElementById('dr-last-sync').textContent = d.toLocaleString();
                document.getElementById('dr-last-sync').className = 'sync-status-value good';
            } else {
                document.getElementById('dr-last-sync').textContent = 'Never';
                document.getElementById('dr-last-sync').className = 'sync-status-value warn';
            }

            const apiEl = document.getElementById('dr-api-status');
            apiEl.textContent = apiOk ? 'Connected' : 'Not Available';
            apiEl.className = 'sync-status-value ' + (apiOk ? 'good' : 'bad');

            const healthEl = document.getElementById('dr-sync-health');
            if (!apiOk) {
                healthEl.textContent = 'Maps API Offline';
                healthEl.className = 'sync-status-value bad';
            } else if (count === 0) {
                healthEl.textContent = 'Cache Empty';
                healthEl.className = 'sync-status-value warn';
            } else if (!lastSync) {
                healthEl.textContent = 'Never Synced';
                healthEl.className = 'sync-status-value warn';
            } else {
                healthEl.textContent = 'OK';
                healthEl.className = 'sync-status-value good';
            }
        }

        // Appends an HTML line to the terminal output, removes the old
                // blinking cursor, re-adds it at the end, and auto-scrolls.
        function drLog(html) {
            const terminal = document.getElementById('dr-terminal');
            // Remove cursor if present
            const cursor = terminal.querySelector('.t-cursor');
            if (cursor) cursor.remove();
            terminal.innerHTML += html + '<br>';
            // Re-add cursor at end
            const cur = document.createElement('span');
            cur.className = 't-cursor';
            terminal.appendChild(cur);
            terminal.scrollTop = terminal.scrollHeight;
        }

        // Returns the current time as HH:MM:SS (24h) for terminal log lines.
        function drTimestamp() {
            return new Date().toLocaleTimeString('en-US', { hour12: false });
        }

        // Enables or disables all three Distance Refresh action buttons
                // while a fetch is in progress.
        function drSetButtonsDisabled(disabled) {
            ['dr-btn-all', 'dr-btn-used', 'dr-btn-clear'].forEach(id => {
                document.getElementById(id).disabled = disabled;
            });
        }

        // Wipes maps_distances_v2 and the last-sync timestamp from
                // localStorage and logs the result to the terminal.
        function clearDistanceCache() {
            const terminal = document.getElementById('dr-terminal');
            terminal.innerHTML = '';
            drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-warn">Clearing distance cache…</span>`);
            const cache = JSON.parse(localStorage.getItem('maps_distances_v2') || '{}');
            const count = Object.keys(cache).length;
            localStorage.removeItem('maps_distances_v2');
            localStorage.removeItem('alm_last_distance_sync');
            drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-ok">✓ Cache cleared.</span> <span class="t-dim">${count} entries removed.</span>`);
            drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-dim">Ready for next sync.</span>`);
            updateDrStatusBar();
            showToast('Distance cache cleared', 'success');
        }

        // Holds fetched route alternatives keyed by "fromKey_toKey"
        let drFetchedRoutes = {};
        let drPickerSelections = {};

        // Main refresh loop. Determines pairs (all or used-routes-only),
                // fetches Directions API alternatives for each, stores results in
                // drFetchedRoutes, then renders the route picker cards.
        async function runDistanceRefresh(mode) {
            if (drRunning) return;
            if (typeof google === 'undefined' || !google.maps || !directionsService) {
                showToast('Google Maps API not available', 'error');
                const terminal = document.getElementById('dr-terminal');
                terminal.innerHTML = '';
                drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-error">✗ ERROR: Google Maps API not available.</span>`);
                drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-warn">Check API connection and try again.</span>`);
                return;
            }

            drRunning = true;
            drFetchedRoutes = {};
            drPickerSelections = {};
            drSetButtonsDisabled(true);

            // Hide picker section from previous run
            document.getElementById('dr-picker-section').style.display = 'none';
            document.getElementById('dr-picker-list').innerHTML = '';

            const terminal = document.getElementById('dr-terminal');
            terminal.innerHTML = '';

            drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-hi">ALM Distance Refresh — ${mode === 'all' ? 'Full (All Pairs)' : 'Used Routes Only'}</span>`);
            drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-dim">──────────────────────────────────────</span>`);
            drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-dim">Using Directions API — pure road distance, no traffic. You pick the route.</span>`);

            // Step 1: Determine pairs
            drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-warn">Step 1: Determining location pairs…</span>`);
            await drDelay(200);
            let pairs = [];
            const allKeys = Object.keys(ALM_LOCATIONS);

            if (mode === 'all') {
                for (let i = 0; i < allKeys.length; i++)
                    for (let j = 0; j < allKeys.length; j++)
                        if (i !== j) pairs.push([allKeys[i], allKeys[j]]);
                drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-ok">✓ Mode: All Pairs.</span> <span class="t-dim">${pairs.length} directional pairs (${allKeys.length} locations).</span>`);
            } else {
                const routes = JSON.parse(localStorage.getItem('alm_routes') || '[]');
                const pairSet = new Set();
                routes.forEach(route => {
                    if (route.stops && route.stops.length > 1) {
                        for (let i = 0; i < route.stops.length - 1; i++) {
                            const a = route.stops[i].location;
                            const b = route.stops[i + 1].location;
                            if (a && b && a !== b) pairSet.add(`${a}|${b}`);
                        }
                    }
                });
                pairs = Array.from(pairSet).map(s => s.split('|'));
                if (pairs.length === 0) {
                    drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-warn">⚠ No saved routes found. No pairs to refresh.</span>`);
                    drRunning = false;
                    drSetButtonsDisabled(false);
                    updateDrStatusBar();
                    return;
                }
                drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-ok">✓ Mode: Used Routes.</span> <span class="t-dim">${pairs.length} unique directional pairs from ${routes.length} saved routes.</span>`);
            }

            // Step 2: Fetch all alternatives for each pair
            drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-warn">Step 2: Fetching route alternatives for ${pairs.length} pairs…</span>`);
            await drDelay(300);

            let fetched = 0;
            let errors = 0;

            for (let i = 0; i < pairs.length; i++) {
                const [fromKey, toKey] = pairs[i];
                const fromLoc = ALM_LOCATIONS[fromKey];
                const toLoc   = ALM_LOCATIONS[toKey];
                const pairKey = `${fromKey}_${toKey}`;

                if (!fromLoc || !toLoc) { errors++; continue; }

                try {
                    const result = await new Promise((resolve, reject) => {
                        directionsService.route({
                            origin:      new google.maps.LatLng(fromLoc.lat, fromLoc.lng),
                            destination: new google.maps.LatLng(toLoc.lat,   toLoc.lng),
                            travelMode:  google.maps.TravelMode.DRIVING,
                            avoidHighways: false,
                            avoidTolls:    false,
                            region: 'US',
                            provideRouteAlternatives: true
                        }, (res, status) => status === 'OK' ? resolve(res) : reject(new Error(status)));
                    });

                    // Sort alternatives shortest first
                    const sorted = [...result.routes].sort((a, b) => {
                        const distA = a.legs.reduce((s, l) => s + l.distance.value, 0);
                        const distB = b.legs.reduce((s, l) => s + l.distance.value, 0);
                        return distA - distB;
                    });

                    const options = sorted.map(route => ({
                        miles: parseFloat((route.legs.reduce((s, l) => s + l.distance.value, 0) * 0.000621371).toFixed(2))
                    }));

                    drFetchedRoutes[pairKey] = { fromKey, toKey, fromName: fromLoc.name, toName: toLoc.name, options };
                    fetched++;
                    drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-ok">  ✓</span> <span class="t-dim">${fromLoc.name} → ${toLoc.name}:</span> ${options.map((o,i) => `<span class="t-hi">${o.miles}mi</span>`).join(' / ')}`);

                } catch (err) {
                    errors++;
                    drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-error">  ✗ ${fromLoc.name} → ${toLoc.name}: ${err.message}</span>`);
                }

                if (i > 0 && i % 5 === 0) await drDelay(150);
            }

            drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-dim">──────────────────────────────────────</span>`);
            drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-ok">✓ Fetch complete — ${fetched} pairs ready${errors > 0 ? `, ${errors} failed` : ''}.</span>`);
            drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-dim">Choose your preferred route for each pair below, then click Save All.</span>`);

            drRunning = false;
            drSetButtonsDisabled(false);

            // Render the picker cards
            drRenderPickerCards(fetched);
        }

        // Builds one picker card per fetched pair below the terminal.
                // Each card shows route option buttons sorted shortest first.
        function drRenderPickerCards(fetchedCount) {
            const section = document.getElementById('dr-picker-section');
            const list    = document.getElementById('dr-picker-list');
            section.style.display = 'block';

            document.getElementById('dr-picker-fetched').textContent   = fetchedCount;
            document.getElementById('dr-picker-done').textContent      = '0';
            document.getElementById('dr-picker-remaining').textContent = fetchedCount;

            list.innerHTML = '';

            Object.entries(drFetchedRoutes).forEach(([pairKey, pair]) => {
                const card = document.createElement('div');
                card.className = 'route-picker';
                card.id = `drcard-${pairKey}`;
                card.style.marginBottom = '10px';

                const optionsHtml = pair.options.length === 1
                    ? `<span class="route-picker-single">Only 1 route available — </span>
                       <button class="route-option-btn" onclick="drPickRoute('${pairKey}', ${pair.options[0].miles}, this)">
                           <span class="route-option-miles">${pair.options[0].miles} mi</span>
                           <span class="route-option-sub">Confirm</span>
                       </button>`
                    : pair.options.map((opt, idx) =>
                        `<button class="route-option-btn" onclick="drPickRoute('${pairKey}', ${opt.miles}, this)">
                            <span class="route-option-miles">${opt.miles} mi</span>
                            <span class="route-option-sub">Route ${idx + 1}</span>
                         </button>`
                    ).join('');

                card.innerHTML = `
                    <div class="route-picker-label">${pair.fromName} → ${pair.toName}</div>
                    <div class="route-picker-options">${optionsHtml}</div>
                `;
                list.appendChild(card);
            });
        }

        // Records the user's route choice for one pair, highlights the
                // selected button, and updates the done/remaining counters.
                // Unlocks the Save button when all pairs have a selection.
        function drPickRoute(pairKey, miles, btn) {
            const card = document.getElementById(`drcard-${pairKey}`);
            if (card) card.querySelectorAll('.route-option-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');

            const wasSelected = pairKey in drPickerSelections;
            drPickerSelections[pairKey] = miles;

            if (!wasSelected) {
                const done      = Object.keys(drPickerSelections).length;
                const total     = Object.keys(drFetchedRoutes).length;
                const remaining = total - done;
                document.getElementById('dr-picker-done').textContent      = done;
                document.getElementById('dr-picker-remaining').textContent = remaining;

                // Enable Save button once all pairs have a selection
                document.getElementById('dr-save-btn').disabled = remaining > 0;
            }
        }

        // Writes all picker selections to the distance cache at once,
                // stamps the sync timestamp, and refreshes the matrix if visible.
        function drSaveAllPicked() {
            const cache = JSON.parse(localStorage.getItem('maps_distances_v2') || '{}');
            let count = 0;

            Object.entries(drPickerSelections).forEach(([pairKey, miles]) => {
                cache[pairKey] = miles;
                count++;
            });

            localStorage.setItem('maps_distances_v2', JSON.stringify(cache));
            const now = new Date().toISOString();
            localStorage.setItem('alm_last_distance_sync', now);

            // Log to terminal
            drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-dim">──────────────────────────────────────</span>`);
            drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-ok">✓ SAVED — ${count} route selections written to cache.</span>`);
            drLog(`<span class="t-ts">[${drTimestamp()}]</span> <span class="t-dim">Sync timestamp: ${new Date(now).toLocaleString()}</span>`);

            // Refresh matrix live if it's the active page
            if (document.getElementById('matrix-page')?.classList.contains('active')) {
                loadDistanceMatrix();
            }

            // Hide picker, update status
            document.getElementById('dr-picker-section').style.display = 'none';
            updateDrStatusBar();
            showToast(`${count} distances saved to cache`, 'success');

            // Reset state
            drFetchedRoutes = {};
            drPickerSelections = {};
        }

        // Simple Promise-based delay used to pace terminal log output
                // so it feels like a real terminal rather than instant output.
        function drDelay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ════════════════════════════════════════════════════════════════════
        //  DISTANCE SPOT-CHECK
        //  Test a single location pair against the live API. Shows cached vs
        //  live distance, diff %, and a route picker to update the cache.
        // ════════════════════════════════════════════════════════════════════

        let scLog = [];

        // Populates the start and end dropdowns with all current locations
                // and renders the session check log.
        function initSpotCheckPage() {
            const startSel = document.getElementById('sc-start');
            const endSel   = document.getElementById('sc-end');
            startSel.innerHTML = '<option value="">Choose start…</option>';
            endSel.innerHTML   = '<option value="">Choose end…</option>';
            Object.entries(ALM_LOCATIONS).forEach(([key, loc]) => {
                startSel.innerHTML += `<option value="${key}">${loc.name}</option>`;
                endSel.innerHTML   += `<option value="${key}">${loc.name}</option>`;
            });
            renderScLog();
        }

        // Fetches the live Directions API distance for the selected pair,
                // compares it to the cached value, shows the diff, and renders
                // route picker buttons so the user can update the cache.
        async function runSpotCheck() {
            const fromKey = document.getElementById('sc-start').value;
            const toKey   = document.getElementById('sc-end').value;

            if (!fromKey || !toKey) { showToast('Choose both locations', 'warning'); return; }
            if (fromKey === toKey)  { showToast('Start and end must differ', 'warning'); return; }

            const fromLoc = ALM_LOCATIONS[fromKey];
            const toLoc   = ALM_LOCATIONS[toKey];

            // Show result panel
            const panel = document.getElementById('sc-result');
            panel.classList.add('show');
            document.getElementById('sc-pair').textContent = `${fromLoc.name} → ${toLoc.name}`;

            // Cached distance
            const cache = JSON.parse(localStorage.getItem('maps_distances_v2') || '{}');
            const cacheKey = `${fromKey}_${toKey}`;
            const cached = cache[cacheKey];
            const cachedEl = document.getElementById('sc-cached');
            if (cached !== undefined) {
                cachedEl.textContent = cached + ' mi';
                cachedEl.className = 'spotcheck-val';
            } else {
                cachedEl.textContent = 'Not in cache';
                cachedEl.className = 'spotcheck-val mismatch';
            }

            // Live API
            const liveEl  = document.getElementById('sc-live');
            const diffEl  = document.getElementById('sc-diff');
            const badgeEl = document.getElementById('sc-badge');
            liveEl.textContent  = 'Fetching from API…';
            liveEl.className    = 'spotcheck-val pending';
            diffEl.textContent  = '—';
            badgeEl.innerHTML   = '';

            // Hide picker from any previous run
            const pickerEl = document.getElementById('sc-route-picker');
            if (pickerEl) { pickerEl.style.display = 'none'; document.getElementById('sc-picker-options').innerHTML = ''; }

            document.getElementById('sc-btn').disabled = true;

            if (typeof google === 'undefined' || !google.maps) {
                liveEl.textContent = 'Maps API unavailable';
                liveEl.className   = 'spotcheck-val mismatch';
                badgeEl.innerHTML  = '<span class="match-badge mismatch">API ERROR</span>';
                document.getElementById('sc-btn').disabled = false;
                return;
            }

            try {
                // Use Directions API with alternatives — same as route builder
                const result = await new Promise((resolve, reject) => {
                    directionsService.route({
                        origin:      new google.maps.LatLng(fromLoc.lat, fromLoc.lng),
                        destination: new google.maps.LatLng(toLoc.lat,   toLoc.lng),
                        travelMode:  google.maps.TravelMode.DRIVING,
                        avoidHighways: false,
                        avoidTolls:    false,
                        region: 'US',
                        provideRouteAlternatives: true
                        // No drivingOptions — pure road distance, no traffic
                    }, (res, status) => status === 'OK' ? resolve(res) : reject(new Error(status)));
                });

                // Sort all routes shortest first
                const sorted = [...result.routes].sort((a, b) => {
                    const dA = a.legs.reduce((s, l) => s + l.distance.value, 0);
                    const dB = b.legs.reduce((s, l) => s + l.distance.value, 0);
                    return dA - dB;
                });
                const options = sorted.map(r => parseFloat((r.legs.reduce((s, l) => s + l.distance.value, 0) * 0.000621371).toFixed(2)));
                const liveMiles = options[0]; // shortest for display/comparison

                liveEl.textContent = `${liveMiles} mi (${options.length} route${options.length > 1 ? 's found' : ' available'})`;
                liveEl.className   = 'spotcheck-val match';

                if (cached !== undefined) {
                    const diff = Math.abs(liveMiles - cached).toFixed(2);
                    const pct  = ((Math.abs(liveMiles - cached) / liveMiles) * 100).toFixed(1);
                    diffEl.textContent = `${diff} mi (${pct}%)`;
                    diffEl.className   = parseFloat(diff) < 0.5 ? 'spotcheck-val match' : 'spotcheck-val mismatch';
                    const isMatch = parseFloat(diff) < 0.5;
                    badgeEl.innerHTML = isMatch
                        ? '<span class="match-badge match">✓ MATCH</span>'
                        : '<span class="match-badge mismatch">✗ MISMATCH</span>';
                    scLog.unshift({ time: new Date().toLocaleTimeString(), from: fromLoc.name, to: toLoc.name, cached, live: liveMiles, diff, match: isMatch });
                } else {
                    diffEl.textContent = 'No cache to compare';
                    badgeEl.innerHTML  = '<span class="match-badge no-cache">NO CACHE</span>';
                    scLog.unshift({ time: new Date().toLocaleTimeString(), from: fromLoc.name, to: toLoc.name, cached: null, live: liveMiles, diff: null, match: null });
                }

                // Always show route picker so user can choose which to cache
                const pickerEl = document.getElementById('sc-route-picker');
                const pickerId = 'sc-picker-options';
                if (pickerEl) {
                    pickerEl.style.display = 'block';
                    document.getElementById(pickerId).innerHTML = options.length === 1
                        ? `<span class="route-picker-single">Only 1 route available — </span>
                           <button class="route-option-btn" onclick="scPickAndSave('${fromKey}','${toKey}',${options[0]},this)">
                               <span class="route-option-miles">${options[0]} mi</span>
                               <span class="route-option-sub">Save to Matrix</span>
                           </button>`
                        : options.map((mi, i) =>
                            `<button class="route-option-btn" onclick="scPickAndSave('${fromKey}','${toKey}',${mi},this)">
                                <span class="route-option-miles">${mi} mi</span>
                                <span class="route-option-sub">Route ${i + 1}${i === 0 ? ' — shortest' : ''}</span>
                             </button>`
                          ).join('');
                }

            } catch (err) {
                liveEl.textContent = 'Error: ' + err.message;
                liveEl.className   = 'spotcheck-val mismatch';
                badgeEl.innerHTML  = '<span class="match-badge mismatch">ERROR</span>';
            }

            document.getElementById('sc-btn').disabled = false;
            renderScLog();
        }

        // Rebuilds the Recent Checks log from the in-memory scLog array
                // (last 20 entries, newest first).
        function renderScLog() {
            const container = document.getElementById('sc-log');
            if (!container) return;
            if (scLog.length === 0) {
                container.innerHTML = '<div style="color:#555; font-size:13px; font-family:\'Courier New\',monospace;">No checks run yet.</div>';
                return;
            }
            container.innerHTML = scLog.slice(0, 20).map(entry => {
                let result;
                if (entry.match === null && entry.cached === null) {
                    result = `<span class="log-miss">NO CACHE — live: ${entry.live} mi</span>`;
                } else if (entry.match) {
                    result = `<span class="log-match">✓ MATCH — cached: ${entry.cached} mi, live: ${entry.live} mi (Δ${entry.diff} mi)</span>`;
                } else if (entry.match === false) {
                    result = `<span class="log-miss">✗ MISMATCH — cached: ${entry.cached} mi, live: ${entry.live} mi (Δ${entry.diff} mi)</span>`;
                } else {
                    result = `<span style="color:#ffa726;">ERROR</span>`;
                }
                return `<div class="spotcheck-log-entry"><span class="log-time">[${entry.time}]</span>  ${entry.from} → ${entry.to} — ${result}</div>`;
            }).join('');
        }

        // Empties the scLog array and clears the log display.
        function clearSpotCheckLog() {
            scLog = [];
            renderScLog();
        }

        // Saves the user's chosen route distance to the cache, refreshes
                // the matrix if open, and updates the result panel to show SAVED.
        function scPickAndSave(fromKey, toKey, miles, btn) {
            // Highlight selected button
            document.querySelectorAll('#sc-picker-options .route-option-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');

            // Write to cache
            const cache = JSON.parse(localStorage.getItem('maps_distances_v2') || '{}');
            cache[`${fromKey}_${toKey}`] = miles;
            localStorage.setItem('maps_distances_v2', JSON.stringify(cache));

            // Refresh matrix if it's currently the active page
            if (document.getElementById('matrix-page')?.classList.contains('active')) {
                loadDistanceMatrix();
            }

            showToast(`✓ Matrix updated: ${ALM_LOCATIONS[fromKey].name} → ${ALM_LOCATIONS[toKey].name} = ${miles} mi`, 'success');

            // Update the cached row in the result panel to reflect the new value
            const cachedEl = document.getElementById('sc-cached');
            if (cachedEl) {
                cachedEl.textContent = miles + ' mi';
                cachedEl.className = 'spotcheck-val match';
            }
            const diffEl = document.getElementById('sc-diff');
            if (diffEl) { diffEl.textContent = '0.00 mi (0.0%)'; diffEl.className = 'spotcheck-val match'; }
            const badgeEl = document.getElementById('sc-badge');
            if (badgeEl) badgeEl.innerHTML = '<span class="match-badge match">✓ SAVED</span>';
        }

        // Keep scWriteToCache as alias so any lingering references don't break
        // Legacy alias kept so any old inline onclick references still work.
                // Prefer scPickAndSave() for new code.
        function scWriteToCache(fromKey, toKey, miles) {
            const cache = JSON.parse(localStorage.getItem('maps_distances_v2') || '{}');
            cache[`${fromKey}_${toKey}`] = miles;
            localStorage.setItem('maps_distances_v2', JSON.stringify(cache));
            if (document.getElementById('matrix-page')?.classList.contains('active')) loadDistanceMatrix();
            showToast(`Cached: ${ALM_LOCATIONS[fromKey].name} → ${ALM_LOCATIONS[toKey].name} = ${miles} mi`, 'success');
            runSpotCheck();
        }

        // ════════════════════════════════════════════════════════════════════
        //  LEGACY STUBS
        //  Thin wrappers kept so any old references in localStorage or bookmarks
        //  don't throw errors. Do not add new code here.
        // ════════════════════════════════════════════════════════════════════

        // Legacy navigation helper — clicks the nav item for the given page
                // name. Use the nav item's click() directly in new code.
        function navigateTo(page) {
            const navItem = document.querySelector(`.nav-item[data-page="${page}"]`);
            if (navItem) navItem.click();
        }

        // Legacy stub — navigates to the Distance Refresh page.
        function refreshDistances() {
            navigateTo('dist-refresh');
        }

        // ════════════════════════════════════════════════════════════════════
        //  EXCEL EXPORT
        //  Generate a SheetJS workbook with a Summary sheet (one row per trip)
        //  and a Detailed Legs sheet, then trigger a browser download.
        // ════════════════════════════════════════════════════════════════════

        // Builds a SheetJS workbook with a Summary sheet (one row per saved
                // route) and a Detailed Legs sheet, then triggers a .xlsx download.
        function downloadExcel() {
            const routes = JSON.parse(localStorage.getItem('alm_routes') || '[]');
            
            if (routes.length === 0) {
                showToast('No data to export', 'warning');
                return;
            }
            
            // Create summary worksheet
            const summaryData = [
                ['Date', 'Purpose', 'Start', 'End', 'Total Miles', 'Reimbursable', 'Cost', 'Synced']
            ];
            
            routes.forEach(route => {
                const startLocation = route.stops && route.stops[0] ? route.stops[0].name : 'Unknown';
                const endLocation = route.stops && route.stops[route.stops.length - 1] ? route.stops[route.stops.length - 1].name : 'Unknown';
                
                summaryData.push([
                    route.date,
                    route.purpose || '',
                    startLocation,
                    endLocation,
                    route.totalMiles || 0,
                    route.reimbursable ? 'Yes' : 'No',
                    route.cost || 0,
                    route.synced ? 'Yes' : 'No'
                ]);
            });
            
            // Create detailed legs worksheet
            const detailedData = [
                ['Date', 'Route ID', 'Leg', 'From', 'To', 'Miles']
            ];
            
            routes.forEach(route => {
                if (route.stops && route.stops.length > 1) {
                    for (let i = 0; i < route.stops.length - 1; i++) {
                        const legMiles = calculateLegDistance(route.stops[i], route.stops[i + 1]);
                        detailedData.push([
                            route.date,
                            route.id,
                            i + 1,
                            route.stops[i].name,
                            route.stops[i + 1].name,
                            legMiles
                        ]);
                    }
                }
            });
            
            // Create workbook
            const wb = XLSX.utils.book_new();
            
            // Add summary sheet
            const summaryWs = XLSX.utils.aoa_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(wb, summaryWs, 'Summary');
            
            // Add detailed legs sheet
            const detailedWs = XLSX.utils.aoa_to_sheet(detailedData);
            XLSX.utils.book_append_sheet(wb, detailedWs, 'Detailed Legs');
            
            // Download file
            const today = new Date().toISOString().split('T')[0];
            const filename = `ALM_Mileage_Export_${today}.xlsx`;
            XLSX.writeFile(wb, filename);
            
            showToast(`Exported ${routes.length} routes to ${filename}`, 'success');
        }

        // ════════════════════════════════════════════════════════════════════
        //  MATH & DISTANCE UTILITIES
        //  calculateLegDistance: cache-only lookup (returns 0 if missing).
        //  haversineDistance/toRadians: kept for reference, not used in routes.
        // ════════════════════════════════════════════════════════════════════

        // Looks up the cached API distance for a leg. Returns 0 if the
                // pair is not yet cached — run Distance Refresh to populate.
        function calculateLegDistance(fromStop, toStop) {
            // Only use cached API values — no haversine fallback (it's too inaccurate)
            const cachedDistances = JSON.parse(localStorage.getItem('maps_distances_v2') || '{}');
            const cacheKey = `${fromStop.location}_${toStop.location}`;
            if (cachedDistances[cacheKey] !== undefined) {
                return cachedDistances[cacheKey];
            }
            // No cache available — return 0 and let the caller handle it
            // Run a Distance Refresh to populate the cache
            return 0;
        }

        // Great-circle distance between two lat/lng points in miles.
                // Kept for reference — not used in active route calculations.
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 3959; // Earth's radius in miles
            const dLat = toRadians(lat2 - lat1);
            const dLon = toRadians(lon2 - lon1);
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // Converts decimal degrees to radians. Used by haversineDistance.
        function toRadians(degrees) {
            return degrees * (Math.PI / 180);
        }

        // ════════════════════════════════════════════════════════════════════
        //  EXCEL IMPORT
        //  Open a file picker, read the .xlsx with SheetJS, parse rows into
        //  route objects, and run conflict detection before merging.
        // ════════════════════════════════════════════════════════════════════

        // Opens a file picker for .xlsx/.xls files, reads the file with
                // SheetJS, parses rows, and runs conflict detection before merging.
        function importExcel() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.xlsx,.xls';
            
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                showToast('Processing Excel file...', 'warning');
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const data = new Uint8Array(event.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        
                        // Parse the Summary sheet
                        const summarySheetName = workbook.SheetNames.find(name => 
                            name.toLowerCase().includes('summary') || name === 'Sheet1'
                        ) || workbook.SheetNames[0];
                        
                        if (!summarySheetName) {
                            throw new Error('No valid sheet found in Excel file');
                        }
                        
                        const summarySheet = workbook.Sheets[summarySheetName];
                        const summaryData = XLSX.utils.sheet_to_json(summarySheet);
                        
                        const importedRoutes = parseExcelData(summaryData);
                        handleImportedRoutes(importedRoutes);
                        
                    } catch (error) {
                        console.error('Excel import error:', error);
                        showToast('Error processing Excel file: ' + error.message, 'error');
                    }
                };
                reader.readAsArrayBuffer(file);
            };
            
            input.click();
        }

        // Converts raw SheetJS row objects (with flexible column names) into
                // the internal route format used by handleImportedRoutes().
        function parseExcelData(data) {
            const routes = [];
            
            data.forEach((row, index) => {
                try {
                    // Handle different possible column names
                    const date = row['Date'] || row['date'] || row['DATE'];
                    const purpose = row['Purpose'] || row['purpose'] || row['PURPOSE'] || '';
                    const startLoc = row['Start'] || row['start'] || row['From'] || row['from'];
                    const endLoc = row['End'] || row['end'] || row['To'] || row['to'];
                    const miles = parseFloat(row['Total Miles'] || row['Miles'] || row['total_miles'] || row['miles'] || 0);
                    const reimbursable = String(row['Reimbursable'] || row['reimbursable'] || 'Yes').toLowerCase() === 'yes';
                    const cost = parseFloat(row['Cost'] || row['cost'] || (miles * IRS_RATE));
                    
                    if (!date) {
                        console.warn(`Skipping row ${index + 1}: No date found`);
                        return;
                    }
                    
                    // Convert Excel date if needed
                    let formattedDate;
                    if (typeof date === 'number') {
                        // Excel date number
                        const excelDate = new Date((date - 25569) * 86400 * 1000);
                        formattedDate = excelDate.toISOString().split('T')[0];
                    } else {
                        // String date
                        formattedDate = new Date(date).toISOString().split('T')[0];
                    }
                    
                    // Create stops array
                    const stops = [];
                    if (startLoc) {
                        const startKey = findLocationKey(startLoc);
                        if (startKey) {
                            stops.push({ location: startKey, name: ALM_LOCATIONS[startKey].name });
                        }
                    }
                    if (endLoc && endLoc !== startLoc) {
                        const endKey = findLocationKey(endLoc);
                        if (endKey) {
                            stops.push({ location: endKey, name: ALM_LOCATIONS[endKey].name });
                        }
                    }
                    
                    const route = {
                        id: 'import_' + Date.now() + '_' + index,
                        date: formattedDate,
                        purpose: purpose,
                        stops: stops,
                        totalMiles: miles,
                        reimbursable: reimbursable,
                        cost: cost,
                        timestamp: new Date().toISOString(),
                        synced: false
                    };
                    
                    routes.push(route);
                    
                } catch (error) {
                    console.warn(`Error parsing row ${index + 1}:`, error);
                }
            });
            
            return routes;
        }

        // Looks up a location key in ALM_LOCATIONS by matching the display
                // name (case-insensitive). Returns undefined if not found.
        function findLocationKey(locationName) {
            const name = locationName.toLowerCase();
            
            for (const [key, location] of Object.entries(ALM_LOCATIONS)) {
                if (location.name.toLowerCase().includes(name) || 
                    name.includes(location.name.toLowerCase()) ||
                    name.includes(key)) {
                    return key;
                }
            }
            
            return null;
        }

        // Checks imported routes for conflicts with existing data.
                // Shows the conflict modal if any exist, or merges directly if clean.
        function handleImportedRoutes(importedRoutes) {
            if (importedRoutes.length === 0) {
                showToast('No valid routes found in Excel file', 'warning');
                return;
            }
            
            const existingRoutes = JSON.parse(localStorage.getItem('alm_routes') || '[]');
            const conflicts = detectConflicts(importedRoutes, existingRoutes);
            
            if (conflicts.length > 0) {
                // Show conflict resolution modal
                showConflictModal(conflicts);
            } else {
                // No conflicts, proceed with direct import
                const updatedRoutes = [...existingRoutes, ...importedRoutes];
                localStorage.setItem('alm_routes', JSON.stringify(updatedRoutes));
                showToast(`Successfully imported ${importedRoutes.length} routes`, 'success');
            }
        }

        // ════════════════════════════════════════════════════════════════════
        //  TOAST NOTIFICATIONS
        //  showToast(message, type) — displays a temporary overlay message.
        //  Types: 'success' (green), 'warning' (amber), 'error' (red).
        // ════════════════════════════════════════════════════════════════════

        // Creates a toast notification div, appends it to the body,
                // and removes it after 3 seconds. Type controls the color.
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            setTimeout(() => toast.classList.add('show'), 100);
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => document.body.removeChild(toast), 300);
            }, 3000);
        }

        // Handle Google Maps API load error
        window.gm_authFailure = function() {
            updateMapsStatus('disconnected');
            showToast('Google Maps authentication failed - Check API key restrictions', 'error');
            console.error('Google Maps authentication failed. Check API key and restrictions in Google Cloud Console.');
        };

        // Handle other potential Google Maps errors
        window.addEventListener('error', function(e) {
            if (e.message && e.message.includes('Google Maps')) {
                console.error('Google Maps error:', e.message);
                updateMapsStatus('disconnected');
            }
        });

        // Add a fallback check for Maps API availability
        window.addEventListener('load', function() {
            setTimeout(function() {
                if (typeof google === 'undefined' || !isMapInitialized) {
                    updateMapsStatus('disconnected');
                    console.warn('Google Maps failed to initialize. Check console for errors.');
                    
                    // Provide helpful guidance
                    console.log('Troubleshooting steps:');
                    console.log('1. Check API key in Google Cloud Console');
                    console.log('2. Verify Maps JavaScript API is enabled'); 
                    console.log('3. For v13 location features, also enable Geocoding API');
                    console.log('4. Check API key restrictions (HTTP referrers)');
                    console.log('5. Verify billing is set up and quotas not exceeded');
                }
            }, 5000);
        });
    </script>
</body>
</html>